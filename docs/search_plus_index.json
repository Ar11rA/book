{"./":{"url":"./","title":"Introduction","keywords":"","body":"React Native made easy React/Redux best practices + React Native + Robust DevOps pipeline↘️ ⬇️ ↙️A fine native app for iOS, Android (and Web). A reference for building production grade applications which are easy to test, maintain and extend to multiple platforms. This book is for the Web developers who have already got their hands dirty with react and ES6 and want to build complex native apps. You will learn: How react native internally works and how to debug RN apps. How to test and write modular code in react-native. Redux: The state container. How to setup a good devops pipeline which will increase team's productivity and ensure seamless testing. How you can extend your react-native codebase to support web or any other platform by just following some code conventions. We are following native-first approach with an eye on web. You will eventually see how easy it is port the application to Web by following conventions and stuff. The knowledge is based on the experience of working with React Native apps for around 2 years and helping clients launch their apps quicker than ever before. This book is for: React developers who are planning to start with react-native applications. Web Developers who know basic ReactJS fundamentals and planning to learn best practices for state management and learn native development. Native iOS/Android developers who know ReactJS and want to start building apps using React-Native. react-native developers who want to extend their codebase to support other platforms by just following some code conventions. We will be building an application while learning react-native. So be ready to get your hands dirty. GET, SET, CODE!! "},"3-react-native-internals/3.1-react-native-internals.html":{"url":"3-react-native-internals/3.1-react-native-internals.html","title":"React Native Internals","keywords":"","body":"React Native Internals React Native is a framework which allows developers to build native apps using Javascript. Wait! Cordova already does that and has been around for quite a while. Why will anyone want to use RN ? The primary difference between RN and Cordova based apps is that Cordova based apps run inside a webview while RN apps render using native views. RN apps have direct access to all the Native APIs and views offered by the underlying mobile OS. Thus, RN apps have the same feel and performance of the native application. At first, its easy to assume that react native might be compiling JS code into the respective native code directly. But this would be really hard to achieve since Java and Objective C are strongly typed languages while Javascript is not ! Instead RN does something much much clever. React Native essentially can be considered as a set of React components, where each component represents the corresponding native views and components. For example, a native TextInput will have a corresponding RN component which can be directly imported onto the JS code and used like any other react component. Hence, the developer will be writing the code just like for any other React web app but the output will be a native app. Ok ! This all looks black magic 🙄. To understand this, lets take a look at the architecture and how react native works internally. Architecture 🤖 Both IOS and Android have a similar architecture with subtle differences. If we consider the big picture, there are three parts to the RN platform: Native Code/Modules : Most of the native code in case of IOS is written in Object C or Swift. While in case of android it is Java. But for most cases we will not need to write any native code while writing our react native app. Javascript VM : The JS Virtual Machine that runs all our JavaScript code. On iOS/Android simulators and devices React Native uses JavaScriptCore, which is the JavaScript engine that powers Safari. JavaScriptCore is an open source JavaScript engine originally built for WebKit. Incase of IOS, React Native uses the IOS platform - provided JavaScriptCore. It was first introduced in IOS 7 along with OSX Mavericks. https://developer.apple.com/reference/javascriptcore. In case of Android, React Native bundles the JavaScriptCore along with the application. This increases the app size. Hence the hellow world application of RN would take around 3 to 4 megabytes. In case of Chrome debugging mode, the JavaScript code runs within Chrome itself (instead of the JavaScriptCore on the device) and communicates with native code via WebSocket. So, here it will use the V8 engine. This allows us to see a lot of information on the chrome debugging tools like network requests, console logs ,etc. 😎 React Native Bridge : React Native bridge is a C++/Java bridge which is responsible for communication between the native and Javascript thread. A custom protocol is used for message passing. In most cases, a developer would write the entire react native application in Javascript. To run the application one of the following commands are issued via the cli - react-native run-ios or react-native run-android. At this point React native cli would spawn a node packager/bundler that would bundle the js code into a single main.bundle.js file. The packager can be considered something similar to webpack. Now, whenever the react native app is launched, at first the native entry point view is loaded. The Native thread spawns the JS VM thread onto which the bundled JS code is run. The JS code has all the business logic of the application. The Native thread now sends messages via the RN Bridge to start the JS application. Now the spawned Javascript thread starts issuing instructions to the native thread via the RN Bridge. The instructions include what views to load, what information to be retrieved from the hardware, etc. For example, if the js thread wants a view and text to be created it will batch the request onto a single message and send it across to native to render them. [ [2,3,[2,'Text',{...}]] [2,3,[3,'View',{...}]] ] The native thread will perform these operations and send the result back to the JS assuring that the operations have been performed. Note: To see the bridge messages on the console, just put the following snippet onto the index..js file import MessageQueue from 'react-native/Libraries/BatchedBridge/MessageQueue'; MessageQueue.spy(true); Threading Model 🚧 When a react native application is launched , it spawns up the following threading queues. Main thread (Native Queue) - This is the main thread which gets spawned as soon as the application launches. It loads the app and starts the JS thread to execute the Javascript code. The native thread also listens to the UI events like 'press' , 'touch', etc. These events are then passed onto the JS thread via the RN Bridge. Once the Javascript loads, the JS thread sends the information on what needs to be rendered onto the screen. This information is used by a shadow node thread to compute the layouts. The shadow thread is basically like a mathematical engine which finally decides on how to compute the view positions. These instructions are then passed back to the main thread to render the view. Javascript thread (JS Queue) - The Javascript Queue is the thread queue where main bundled JS thread runs. The JS thread runs all the business logic - the code we write in React. Custom Native Modules - Apart from the threads spawned by React Native, we can also spawn threads on the custom native modules we build to speed up the performance of the application. For example - Animations are handled in React Native by a separate native thread to offload the work from the JS thread. Links: https://www.youtube.com/watch?v=0MlT74erp60 View Managers 👓 View Manager is a native module that maps JSX Views onto Native Views. For example: import React, { Component } from 'react'; import { Text, View, AppRegistry } from 'react-native'; class HelloWorldApp extends Component { render() { return ( Hello world! ); } } export default HelloWorldApp; AppRegistry.registerComponent('HelloWorldApp', () => HelloWorldApp); Here when we write , the Text View manager will invoke new TextView(getContext()) in case of android. View Managers are basically classes extended from ViewManager class in Android and subclasses of RCTViewManager in IOS. Development mode 🔨 When the app is run on DEV mode ,the Javascript thread is spawned on the development machine. Even though the JS code is running on a more powerful machine as compared to a phone, you will soon notice that the performance is considerably low as compared to when run in bundled mode or production mode. This is unavoidable because a lot more work is done in DEV mode at runtime to provide good warnings and error messages, such as validating propTypes and various other assertions. Furthermore, latency of communication between the device and the JS thread also comes to play here. Link : https://www.youtube.com/watch?v=8N4f4h6SThc - RN android architecture "},"4-setting-up-the-project/4.1-installing-react-native.html":{"url":"4-setting-up-the-project/4.1-installing-react-native.html","title":"Setting up the project","keywords":"","body":"Setting up the Project This section covers the basic boilerplate setup of a sample project that we will be using to learn. We believe that one should setup his/her project from scratch or use a minimal boilerplate instead of using a ready made feature rich boilerplate. The reason being , when a developer/team sets up its own boiler plate , they know what exactly is going into the app. A lot of boiler plates have features/libraries which the team will be unaware of and would contribute to the clutter. Popular boilerplates review create-react-native-app OR Expo OR react-native init React-native has a bunch of options to setup the project. create-react-native-app, react-native init and EXPO are among most popular ones and interestingly all three of them are mentioned in the official website of react-native. It might create a lot of confusion for someone who is starting to know which one to use. Here is short desciption for each of them: create-react-native-app: It is similar to the creat-react-app. It has all the necessary tasks to run your application. All the necessary setup has been taken care and you can start hacking around react-native. This is very useful if you are starting to learn react-native and you don't want to worry about anything else. It uses Exponent's open source tools to debug the application. To run the app, all you need to do is install expo client app and scan a QR code. Although its very quick to setup, everything seems like a black-box. Due to this, it can get pretty messy when you want to change a lot of configurations. Hence we do not recommend it for a long term production application. Expo: It is a third party framework which provides you with a lot of cool features like: sharing your app with anyone while your are developing it, live code changes on your real device by just scanning a QR, generating IPA/APK files for you. We do not recommend using this if your app uses a lot of third party native modules or you wish to hack around the native code. Also, It supports only android 4.4 and up. which can be a big turn off if you user base has a large number of android 4.1 - 4.3 users. react-native init: This provides you with the very basic setup of the application including native ios and android folders. This allows you to change native code if required. You would use native android/ios simulators or devices to run your application.You have 2 separate files which defines entry points for android and ios. You can run the dev version of the application by react-native run-ios (It will open the ios emulator and run your app on it). Here we will need to setup everything from scratch. But on the contrary we get full access to native code and have control over almost everything that is going on with our application. Another factor is, it is easier to upgrade react-native and other core libraries using this boilerplate as compared to others. Hence any critical updates can be integrated much easily. Thus, we recommend this boilerplate for any long term production application. Setup instructions for react-native init can be found at https://facebook.github.io/react-native/docs/getting-started.html. Open up the page in a browser and select the second tab, Building Projects with Native Code and follow the instructions. "},"5-project-structure-and-start-building-some-app/5.0-intro.html":{"url":"5-project-structure-and-start-building-some-app/5.0-intro.html","title":"Project Structure","keywords":"","body":"Project structure We will be creating a Note Taking App in React Native.Lets call it NoteTaker. By the end of this book we will be able to build and deploy the NoteTaker to the Android play store and the Apple app store for users to download. We will begin with the standard react native boiler plate and as we progress through the concepts we will keep updating the app. Also, at the end of the book we will also show how to extend our app originally written in Android and IOS to any other platforms, for example: Web (because we just love web). So, Lets begin. Boilerplate To create a new project run react-native init . Example: react-native init notetaker. We will use this project as our base in this book. Once the project setup is complete you should have a project structure similar to this. . ├── .babelrc ├── .buckconfig ├── .flowconfig ├── .gitattributes ├── .gitignore ├── .watchmanconfig ├── android ├── ios ├── node_modules ├── __tests__ │ ├── index.android.js │ └── index.ios.js ├── app.json ├── index.android.js ├── index.ios.js ├── package.json └── yarn.lock Run the app Firsty, lets run the project to see how it looks. Type the command react-native run-ios - for running the app on iOS simulator or react-native run-android - for running the app on a connected android phone /emulator. Note that for react-native run-android to work, you should have an open android emulator or an android device with USB Debugging enabled connected to your laptop via a USB cable. If all goes well you should see the following screen on iOS or android emulator. If you noticed there are two entry point files index.ios.js and index.android.js. Hence, when we run the command react-native run-ios the file index.ios.js serves as our entry point. Under the hood, when we run the command react-native run-ios, first the iOS native project inside ios directory is compiled. Along with the native project react-native packager kicks in on another terminal window and runs on port 8081 by default. The packager is responsible for compilation of javascript code to a js bundle file. When the native project is successfully launched on the simulator, it asks the packager for the bundle file to load. Then all the instructions inside the js code is run to successfully launch the app. The code till here can be found on the branch chapter/5/5.0 "},"5-project-structure-and-start-building-some-app/5.1-customising-the-structure.html":{"url":"5-project-structure-and-start-building-some-app/5.1-customising-the-structure.html","title":"Customizing the project structure","keywords":"","body":"Begin customizing the project Lets begin by creating a directory named app in the project folder. The app folder will have all our javascript source code. Create a file index.js at app/index.js. This file will serve as the common entry point for both android and ios projects. Modify the files as follows: index.ios.js import {AppRegistry} from 'react-native'; import app from './app/index'; AppRegistry.registerComponent('NoteTaker', () => app); export default app; index.android.js import {AppRegistry} from 'react-native'; import app from './app/index'; AppRegistry.registerComponent('NoteTaker', () => app); export default app; app/index.js /** * Sample React Native App * https://github.com/facebook/react-native * @flow */ import React, { Component } from 'react'; import { StyleSheet, Text, View } from 'react-native'; class NoteTaker extends Component { render() { return ( Welcome to React Native! ); } } const styles = StyleSheet.create({ container: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#F5FCFF', }, welcome: { fontSize: 20, textAlign: 'center', margin: 10, }, instructions: { textAlign: 'center', color: '#333333', marginBottom: 5, }, }); export default NoteTaker; As you can see, now we have a single entry point to the code base. Hence both react-native run-android and react-native run-ios will eventually run the same code app/index.js If you run the code now in IOS simulator, you should see Directory structure Now, lets create few directories inside /app, that will help us structure our code such that it is modular and easier to maintain. cd app mkdir assets components config pages redux mkdir routes styles utils So your project directory should now look like this . ├── __tests__ │ ├── index.android.js │ └── index.ios.js ├── app │ ├── assets │ ├── config │ ├── styles │ ├── utils │ ├── components │ ├── pages │ ├── routes │ ├── redux │ └── index.js ├── app.json ├── index.android.js ├── index.ios.js ├── package.json └── yarn.lock app/assets - This is where all the images, videos, etc will go in. app/config - This is where configurations for the app will go in. For example your environment specific config for dev and prod ,etc. app/styles - This is where your global styles, themes and mixins will go. app/utils - This is where all the services/utility files such as http utility to make api calls, storage utility, data transformation utility,etc will go. app/components - The directory will contain all the dumb components. In short these components will only do layouting and wont contain any states or business logic inside them. All the data to these components will be passed in as props. This concept will be explained in much detail later. app/pages - This directory will hold all the smart component. Smart components are those components which contain business logic and states in them. Their job is basically to pass the props to the dumb components after all the business logic is executed. app/routes - This is where we will keep all our app's routing logic. This will contain the map between the pages(smart components) and the routes. app/redux - This will contain all our redux state management files like actions ,reducers, store config, thunks etc. Helper npm scripts Before we continue any further, lets two helper scripts to our package.json Modify the package.json scripts to look like this { ..... ..... ..... \"scripts\": { \"start\": \"node node_modules/react-native/local-cli/cli.js start\", \"test\": \"jest\", \"ios\": \"react-native run-ios\", \"android\": \"cd android && ./gradlew clean && cd .. && react-native run-android\" }, ..... ..... ..... } Here to run the app in iOS we will type yarn ios or yarn run ios from now on the commandline. Similarly, for android we will type yarn android or yarn run android. In case of android we are doing an additional step ./gradlew clean. This allows us to clear any build cache that android created before making an apk. This solves a lot of cache related issues in case of android during development. The code till here can be found on the branch chapter/5/5.1 "},"5-project-structure-and-start-building-some-app/5.2-basic-components-and-platform-specific-code.html":{"url":"5-project-structure-and-start-building-some-app/5.2-basic-components-and-platform-specific-code.html","title":"Creating basic components and writing platform specific code","keywords":"","body":"Creating basic components Since we have a rough idea of what goes where from the previous page, lets create our first basic UI component We will create a simple text area where we can enter our note text. React Native already bundles many basic UI components such as Text, View, TextInput, etc into the package react-native. Below is a table comparing the basic react-native components and their web counterparts: TextArea component Create two files TextArea UI component - app/components/TextArea/TextArea.component.js import React, { Component } from 'react'; import { TextInput, View } from 'react-native'; import PropTypes from 'prop-types'; import styles from './TextArea.component.style'; class TextArea extends Component { state = { text : '' } render() { const {...extraProps} = this.props; return ( this.setState({text})} value={this.state.text} /> ); } } export default TextArea; TextArea style file - app/components/TextArea/TextArea.component.style.js import {StyleSheet} from 'react-native'; export default StyleSheet.create({ textArea: { width: 200, height:100, borderColor: 'gray', borderWidth: 1 } }); This will be our TextArea UI component that we will use to enter our text. Also lets add our UI screen which will contain the TextArea component. Home screen component - app/components/Home/Home.component.js import React, { Component } from 'react'; import { TextInput, View ,Text} from 'react-native'; import PropTypes from 'prop-types'; import styles from './Home.component.style'; import TextArea from '../TextArea/TextArea.component'; class Home extends Component { render() { return ( Please enter your note here ); } } export default Home; Home screen style file - app/components/Home/Home.component.style.js import {StyleSheet} from 'react-native'; export default StyleSheet.create({ container: { flex:1, padding: 20, alignItems: 'center' } }); And finally lets add the Home screen to the main app. Lets, modify the app/index.js to include our home screen. app/index.js /** * Sample React Native App * https://github.com/facebook/react-native * @flow */ import React, { Component } from 'react'; import Home from './components/Home/Home.component'; class NoteTaker extends Component { render() { return ( ); } } export default NoteTaker; If you run the app now, you should have something that looks like this Platform specific code Now as we can see we have different outputs in Android and iOS. To solve this we create an extra file TextArea.component.android.js with the content import React, { Component } from 'react'; import { TextInput, View } from 'react-native'; import PropTypes from 'prop-types'; import styles from './TextArea.component.style'; class TextArea extends Component { state = { text : '' } render() { const {...extraProps} = this.props; const alignTextTop = {textAlignVertical: 'top'}; return ( this.setState({text})} value={this.state.text} underlineColorAndroid={'transparent'} /> ); } } export default TextArea; And reload the app. You should see that both Android and iOS textAreas look the same now. Basically, under the hood while importing/requiring a file say TextArea.component using the syntax import TextArea from './TextArea.component' or var TextArea = require('./TextArea.component') In case of android react native packager while bundling the js files looks for the files in the following order TextArea.component.android.js, TextArea.component.js Similarly, the order in case of iOS is TextArea.component.ios.js , TextArea.component.js Note: Platform specific code can also be written by making use of Platform module from react-native. For example we can also modify TextArea.component.js into import React, { Component } from 'react'; import { TextInput, View } from 'react-native'; import PropTypes from 'prop-types'; import styles from './TextArea.component.style'; import {Platform} from 'react-native'; class TextArea extends Component { state = { text : '' } render() { const {...extraProps} = this.props; const alignTextTop = Platform.OS ==='android' ? {textAlignVertical: 'top'}: {}; return ( this.setState({text})} value={this.state.text} underlineColorAndroid={'transparent'} /> ); } } export default TextArea; Notice that here only single TextArea.component.js file is present for both Android and iOS. This will also produce similar result. But we prefer to use the first method where we create seperate files with .android.js and .ios.js extension. In the case of different extensions we have different files, hence only the code needed for running our logic is bundled into the application. For example: Lets assume you decide that you will use a custom library for TextArea only for android. Now if we import that library only into TextArea.android.js, only for android bundling a new library will be added, iOS will remain the same. Hence, it reduces our code size when bundling. In practice, we have noticed that Platform module method is error prone as we have to manually check for Platform.OS wherever there are subtle differences in the output. The code till here can be found on the branch chapter/5/5.2 "},"6-conventions-and-code-style/6.0-intro.html":{"url":"6-conventions-and-code-style/6.0-intro.html","title":"Coventions and Code Style","keywords":"","body":"Conventions Every team composes of developers who follow different conventions. Hence, often we find that code written by a developer is not easily understood by another developer in the same team. Not having a proper convention creates dependencies on individuals and makes the project difficult to understand by a newcomer. Tight dependencies in a software development project can affect the velocity of the team. The best way to solve this is by deciding and following code conventions. We strongly believe that NO convention is bad. As long as there is some convention and it is followed religiously, its good. Code conventions can be as easy as following 4 spaces instead of tabs, or ending a statement always with semicolon, etc. It could also be something more complex like not allowing setState()to be invoked on componentWillMountof a React Component. So if you want your team to code like this guy, set and follow conventions. "},"6-conventions-and-code-style/6.1-eslint.html":{"url":"6-conventions-and-code-style/6.1-eslint.html","title":"Eslint : The guardian of code conventions ⚔️","keywords":"","body":"Eslint: The guardian of code conventions ⚔️ Eslint is a tool that allows to maintain code quality and enforce code conventions. Eslint is a static code evaluator. Basically, it means that eslint will not actually run the code but will instead read through the source code to see if all the pre - configured code conventions are followed by the developers. Eslint allows to maintain consistent code style throughout the project. Thus, any developer of the team can easily understand the code written by another developer. This can exponentially increase the teams velocity and avoid dependencies. It can prevent human errors and can act as a guardian that maintains code conventions. Examples Apart from code conventions , eslint also spots common mistakes made by developers. For example, var a = 1, b = 2, c = 3, e = 4; var test = function() { console.log(a, b, c, d, e); }; The above code will compile fine. But as soon as u run it , it will throw a runtime exceptionReferenceError test() VM206:4 Uncaught ReferenceError: d is not defined at test (:4:22) at :1:1 test @ VM206:4 (anonymous) @ VM222:1 These mistakes can be easily detected by eslint. Installation It is pretty easy to setup eslint for a project. yarn add --dev eslint babel-eslint eslint eslint-plugin-react eslint-plugin-react-native This would install eslint and other useful plugins as your dev dependencies. And then in your package.json add a npm script as below. So now your package.json should have { \"name\": \"testapp\", \"version\": \"0.0.1\", \"scripts\": { \"start\": \"node node_modules/react-native/local-cli/cli.js start\", .... .... .... \"lint\": \"eslint app/\", \"lint:fix\": \"eslint app/ --fix\" }, \"dependencies\": { .... .... Now you can simply run npm run lint or npm run lint:fix npm run lint will just run the eslint and show a list of errors that need to be fixed.npm run lint:fix will run eslint and attempt to correct the errors it is able to fix automatically. Icing on the cake Most modern editors have support for eslint via plugins. The benefit of a text editor eslint plugin is that these plugins suggest correction while we write code itself thus saving a lot of time for the developer. A editor configured with eslint would look something like this. Also, some of these plugins also support features like lint on save. Thus, eslint attempts to runeslint --fix This fixes all auto fixable lint errors such as incorrect indentation spaces, etc the moment you hit save (cmd+s) on a file. We strongly recommend to enable this feature. The .eslintrc file Eslint rules can be configured via a configuration file .eslintrc which should be placed in the root directory of the project. A sample .eslintrc file looks like this : # \"off\" or 0 - turn the rule off # \"warn\" or 1 - turn the rule on as a warning(doesn’ t affect exit code) # \"error\" or 2 - turn the rule on as an error(exit code is 1 when triggered) { \"parser\": \"babel-eslint\", \"env\": { \"browser\": true }, \"plugins\": [ \"react\", \"react-native\" ], \"ecmaFeatures\": { \"jsx\": true }, \"extends\": [\"eslint:recommended\", \"plugin:react/recommended\"], \"rules\": { \"react/no-did-mount-set-state\": 2, \"react/no-direct-mutation-state\": 2, \"react/jsx-uses-vars\": 2, \"no-undef\": 2, \"semi\": 2, \"react/prop-types\": 2, \"react/jsx-no-bind\": 2, \"react/jsx-no-duplicate-props\": 2, .... .... .... }, \"globals\": { \"GLOBAL\": false, \"it\": false, \"expect\": false, \"describe\": false, .... .... .... } } The important area in the above configuration is the rules section. This section controls all the code conventions followed in the project. Complete list of all the available rules are present here: http://eslint.org/docs/rules/ It can be pretty overwhelming at first to decide which rules should go in. Hence we can start with \"extends\": [\"eslint:recommended\", \"plugin:react/recommended\"] These should cover all the basic rules needed. But we recommend you add these also \"rules\": { \"react/no-did-mount-set-state\": 2, \"react/no-direct-mutation-state\": 2, \"react/jsx-uses-vars\": 2, \"no-undef\": 2, \"semi\": 2, \"react/prop-types\": 2, \"react/jsx-no-bind\": 2, \"react/jsx-no-duplicate-props\": 2, .... .... .... }, Rest of the rules can be added based on what conventions the team decides to follow in the project. Recommendations A suggestion would be that we add more of auto-fixable rules as the corrections suggested by these rules can be auto fixed by the editor with eslint plugin while saving the file itself. This would reduce the time that a developer would spend fixing lint than writing actual code. Also we recommend using eslint for spacing/tabs instead of other methods like.editorconfig. This way, all the code conventions can be configured via single utility (eslint). Also, indentations and spacing can be auto fixed by the editor itself with auto fix on save. The code till here can be found on the branch chapter/6/6.1 "},"6-conventions-and-code-style/6.2-git-pre-hooks.html":{"url":"6-conventions-and-code-style/6.2-git-pre-hooks.html","title":"Github Pre-push/Pre-commit Hooks","keywords":"","body":"Git Pre-push/Pre-commit Hooks Pre-push/Pre-commit hooks are nothing but a couple of commands which you would want to run every time you push/commit something. Now it might not sound that interesting but using them with jest and eslint can protect the code quality of your code at a much, much higher level. How you ask? Pre hooks run a shell command which you specify and if the command fails with exit status 1, the process will get terminated. We store the shell commands inside .git/hooks directory of root of the project. So imagine that you won't be able to push the code if your tests are failing or your js files are not properly linted. That sound's interesting right? Now the next question might be, how do you make sure that everyone adds those commands to the pre-push hooks folder? Don't worry we got that covered as well. Let me introduce you to an awesome NPM module called husky. Using Husky Just do npm install --save-dev husky or yarn add --dev husky After installing these node-modules, all you need to do is specify which command you would like to execute before pushing/committing your code. And all this can be done within package.json. It will make sure to add the commands to your local git hooks folder while setting up (npm install) the machine. We used husky's prepush hook to make sure that every line of code which is being pushed is linted and all the tests pass. If you look at the package.json file of our boilerplate, you would find this snippet: { \"scripts\": { \"prepush\": \"npm run lint && npm run test\", \"postinstall\": \"rm -rf .git/hooks/pre-push && node node_modules/husky/bin/install.js && rm -rf .git/hooks/pre-commit\" }, \"devDependencies\": { \"husky\": \"^0.14.3\" } } As you can see, we are doing npm run lint and npm run test every time the developer tries to push something. If any of the command fails, developer would not be allowed to push and you which greatly reduces the chances of build failure/PR check failure in CIs. Internally, these modules write in .git/hooks folder in pre-commit/pre-push files. After adding these modules and doing npm install, you will find something like this in .git/hooks/pre-push: #!/bin/sh #husky 0.14.3 command_exists () { command -v \"$1\" >/dev/null 2>&1 } has_hook_script () { [ -f package.json ] && cat package.json | grep -q \"\\\"$1\\\"[[:space:]]*:\" } ... ... This code is autogenerated by the node module so we don't have to worry about it. If you are not able to find this file, it means that your hooks were not properly installed. Please uninstall and install the module again or do npm run postinstall. Note: In case windows machine, make sure that you have bash(cygwin). Prepush hooks will fail if you use command prompt The code till here can be found on the branch chapter/6/6.2 "},"6-conventions-and-code-style/6.3-environment-variables.html":{"url":"6-conventions-and-code-style/6.3-environment-variables.html","title":"Environment Variables","keywords":"","body":"Environment variables Since react-native is combines native platform code with JS, you might find it hard to accomplish small tasks like passing environment variables. But don't worry, we got you covered here as well 🙌 How Environment variables work in react-native? Since the JS code is being executed by the native platform, we cannot directly pass env variables like we used to do in node/web pack projects. So we found an alternative way to accomplish this. How to use Environment variables in RN? We created an env.config.js file which exports an object. The env object can contain the API base url, environment, and even the app fixtures/mock api data, etc (we will discuss this in details in API mocks section). And on the CI (travis in our case), we change the contents of the file depending on the build type(Dev, UAT or Prod). Sounds cool right? 🤓 The app will contain all the env configs inside environment/ folder. The CI will replace the contents of env.config.js with environment/prod.config.js before starting the build process. How to change env config using TravisCI? The command is pretty simple. All we need to do is copy the contents from one file to another. cp app/config/env/prod.env.js app/config/env.config.js Head over to TravisCI chapter to know how and where to put the above mentioned command. The code till here can be found on the branch chapter/6/6.3 "},"6-conventions-and-code-style/6.4-es7-features.html":{"url":"6-conventions-and-code-style/6.4-es7-features.html","title":"Speed up development with some and ES7 features 🤘","keywords":"","body":"Speed up development with some and ES7 features. We all have got our hands dirty with ES6 already and we all loved it. React Native supports some of the ES7 features out of the box so no setting up is required to use them. Let me introduce you to some of the ES7 features which will surely help you speed up your development: Class properties instead of constructor We all have used constructor() in our class components and had to use .bind while calling class member functions and faced problems accessing this.setState or this.props. Unfortunately that's how ES6 classes work. I am not gonna explain you why do we need to do all this(there are better resources available online to understand that 😉). But I can tell you a really interesting ES7 feature which you will love. Let me introduce you to ES7 Class instances. By using this feature, you can define class members (state for eg.) without the need of constructor. Before: class SomeComponent extends Component { constructor() { super(); this.state = { count: 0 } } ... } After: class SomeComponent extends Component { state = { count: 0 } ... } Arrow functions instead of class methods Using the above feature, we can also define arrow functions as class instances and since arrow functions does not have their own scope, the this inside arrow function will always point to the class. Therefore you do not need to do binding of this inside constructor. And in most of the cases, you would not be required to use constructor at all. In our project, we never used constructor in any of the components 🤘 Before: class SomeComponent extends Component { _incrementCounter() { this.setState({count: this.state.count+1}) } constructor() { this._incrementCounter = this._incrementCounter.bind(this); } ... } After: class SomeComponent extends Component { _incrementCounter = () => { this.setState({count: this.state.count+1}) } ... } Object rest spread ES6 already supports array spread operator. You can use the same syntax for objects as well. So instead of writing Object.assign({},a,{b:2}), we can directly use {...a, b:2}. You might say that there is nothing new in this. But if used well, it can make your react code much more beautiful and clean. Let me show you the code before and after using spread operator. Before class SomeComponent extends Component { static defaultProps = { someProp: {} } render() { const someProp = this.props.someProp; } } After class SomeComponent extends Component { render() { const {someProp={}} = this.props; } } "},"7-testing/7.0-intro.html":{"url":"7-testing/7.0-intro.html","title":"Testing and Debugging","keywords":"","body":"Testing With the growing complexities of apps, unit testing is a mandate. Since we are writing code in JS, we can utilize most of the testing frameworks/libraries available out there for react/web apps without much changes. We recommend using Jest Framework plus some additional utilities like enzyme to make the developer's life easier. What's the use of testing UI code? We all have asked/been asked this question at least once. And agree or not, the term unit testing was not very popular amongst FE developers until recent years. Here are some of the reasons why we should write unit tests. It lets you capture bugs before the QA team does: We all know that a QA and a dev can never be friends. No dev likes it when QA team finds a bug and tells them to change it. If your code has a good test coverage, there are very less chances to find bugs. Win-win for both sides right? Helps other devs understand your code better. All the test frameworks have describe block where you define what a method does in a language which any human can understand. Need I say more? Refactors your code: You will start asking these questions to yourself while coding: How will I test this code?, How do I make sure that each method I wrote can be tested? If you already ask this questions while writing code, then you are one of the few gems. Makes your code modular: If your code is tested, there are 99% chances that it is modular, which means that you can easily implement changes in future. Makes debugging/implementing changes much, much easier : There will be cases when you will be required to change a functions logic. eg, a currency formatter function which return a string. One way of debugging it would be to go through the UI and check if the desired output is there. Another smart way would be to fire your test case, change the test results according to your desired output and let the test fail. Now change the logic inside your method to make failed the test pass. Does NOT increase the dev time: Many of us give this excuse that writing test cases will increase the dev time(Even I used to do this). But believe me it doesn't. During the course of development almost half of the time is spent in debugging/bug fixing .Writing unit tests can decrease the this value from 50% to less than 20%. "},"7-testing/7.1-jest-setup.html":{"url":"7-testing/7.1-jest-setup.html","title":"Jest setup","keywords":"","body":"Jest setup For all who have not heard about jest, have a quick look here: https://facebook.github.io/jest/ Jest is used by Facebook to test all JavaScript code including React applications. One of Jest's philosophies is to provide an integrated \"zero-configuration\" experience. We observed that when engineers are provided with ready-to-use tools, they end up writing more tests, which in turn results in more stable and healthy code bases. We used Jest because of the following reasons: Minimal Configuration. Watch only changed files. Fast Snapshot testing(Explained later) Coverage out of box 4 important test scripts every project should have \"scripts\": { \"test\": \"jest --verbose --coverage\", \"test:update\": \"jest --verbose --coverage --updateSnapshot\", \"test:watch\": \"jest --verbose --watch\", \"coverage\": \"jest --verbose --coverage && open ./coverage/lcov-report/index.html\", } test: It will go through all the test files and execute them. This command will also be used in pre-hooks and CI checks. test:watch: This will watch all the test files. It is very useful while writing tests and quickly see the result. test:update: This command will update snapshots for all the presentational components. If the snapshot is not there, it will create it for you. We will discuss snapshots in detail in coming chapters. coverage: As the name suggests, this command will generate a coverage report. Testing conventions: It is highly recommended to have conventions for test files as well. Here are the conventions we followed: Jest recommends having a __test__ folder in the same location the file which is to be tested is placed. The name convention for test file is .test.js. if you are writing test for abc.component.js, then the test filename would be abc.component.test.js. In each expect, we write the function name first which is to be tested. Here is a small example following the above mentioned conventions: //counter.util.js const counter = (a) => a + 1; //__test__/counter.util.test.js describe('counter: Should increment the passed value', () => { ... }); JEST configuration: As we read in the documentation, Jest is indeed very easy to setup. You do not need a separate config file, the configuration is so simple that it can fit inside package.json only. Here is our jest config: \"jest\": { \"preset\": \"react-native\", \"cacheDirectory\": \"./cache\", \"coveragePathIgnorePatterns\": [ \"./app/utils/vendor\" ], \"coverageThreshold\": { \"global\": { \"statements\": 80 } }, \"transformIgnorePatterns\": [ \"/node_modules/(?!react-native|react-clone-referenced-element|react-navigation)\" ] } preset: The preset is a node environment that mimics the environment of a React Native app. Because it doesn't load any DOM or browser APIs, it greatly improves Jest's startup time. cacheDirectory: It helps you greatly improve the test speed. It does so by creating cache of compiled modules so that next time it doesn't have to compile the node_modules while running tests. coveragePathIgnorePatterns: Define the files which want to skip for coverage reports. coverageThreshold: Defines the threshold limit for all the tests to pass. If the coverage is less than the defined limit, the tests would fail. This helped us to keep a good amount of coverage at all point of time. transformIgnorePatterns: We pass all the NPM modules here which needs to be transpiled. These modules are basically ES6/7 modules. Note: Make sure to add cache and coverage in your gitignore file. The code till here can be found on the branch chapter/7/7.1 "},"7-testing/7.2-snapshots.html":{"url":"7-testing/7.2-snapshots.html","title":"Snapshots","keywords":"","body":"Snapshots This features makes testing presentational components a lot easier. With a single line, you can test all your presentational components (their render method only). No need to write test cases for each component returned by render method. What are Snapshots: A snapshot is nothing but a configuration file defining your component style, UI and props. The test case will look somthing like this: __tests__/someComponent.component.test.js import React from 'react'; import renderer from 'react-test-renderer'; import SomeComponent from '../SomeComponent.component'; describe('Some component', () => { it('renders correctly', () => { const tree = renderer.create( ).toJSON(); expect(tree).toMatchSnapshot(); }); }); Whenever Jest sees this line expect(tree).toMatchSnapshot();, it is going to generate a snapshot and compare it with stored snapshot. If the snapshot is not present, Jest will store the generated snap. The generated snap file will look something like this: __tests__/snaphots/someComponent.component.js.snap exports[`SomeComponent Component: SomeComponent renders correctly 1`] = ` SomeText `; As you can see above, the snap contains every possible property of the UI which is being returned by the render method. Should I push generated snaps to git? Yes you should. Snaps should be there in each dev's machine so that if one of the devs changes some other component unknowingly, the snap test for that component will fail and he/she would know before pushing it. Even the Jest official documentation says this: It is expected that all snapshots are part of the code that is run on CI and since new snapshots automatically pass, they should not pass a test run on a CI system. It is recommended to always commit all snapshots and to keep them in version control. What to do when snap test fails? Consider this scenario. You worked on a component, generated a snap and pushed it. Later another dev named John made some change in the component. Now the test of the snap will fail since snap still contains the code which you wrote. John will just need to update the snapshot to make the test pass. No need to update the test case, just one command: jest --updateSnapshot and you are done. We recommend creating an npm script for updating snaps. As you can see in the package.json of our boiler plate, it conatains a command called \"test:update\". This command go through all the test cases and will update the snap whenever it is required. More information can be found here: https://facebook.github.io/jest/docs/en/snapshot-testing.html#content "},"7-testing/7.3-enzyme-testing.html":{"url":"7-testing/7.3-enzyme-testing.html","title":"Testing stateful components using Enzyme","keywords":"","body":"Testing stateful components using Enzyme We talked about testing presentational components using our beloved feature called Snaphot testing in Jest. But It just tests the UI of the component(just the render method of your component). What if your component contains some class methods? What if your component contains state? Thats where we use enzyme. What's enzyme? Enzyme is a JavaScript Testing utility for React. You will mostly be using shallow utility from enzyme. Shallow utility helps us rendering a component and allows us accessing the class methods/state of the component. Integrating Enzyme in your current Jest Framework The default react-native boilerplate comes with Jest. Integrating enzyme with Jest is just a two step process. Install enzyme, jest-enzyme, enzyme-adapters yarn add enzyme jest-enzyme enzyme-adapter-react-16 enzyme-react-16-adapter-setup --dev Setup enzyme-react-adaptor and jest-enzyme. Your new package.json should look something like this: package.json { ..., \"jest\": { ..., \"setupTestFrameworkScriptFile\": \"./node_modules/jest-enzyme/lib/index.js\", \"setupFiles\": [\"enzyme-react-16-adapter-setup\"] } } Thats it. You can start using Enzyme utilities now. Using Shallow renderer from enzyme: First we need to shallow render our component. import {shallow} from 'enzyme'; describe('SomeComponent component', () => { it('Shallow rendering', () => { const wrapper = shallow(); }); }); Now Our component is rendered and we can access props/state/methods using wrapper. Here is how you access them: import {shallow} from 'enzyme'; describe('SomeComponent component', () => { it('Shallow rendering', () => { const wrapper = shallow(); const componentInstance = wrapper.instance(); //Accessing react lifecyle methods componentInstance.componentDidMount(); componentInstance.componentWillMount(); //Accessing component state expect(wrapper.state('someStateKey')).toBe(true); //Accessing component props expect(wrapper.props.someProp).toEqual(1); //Accessing class methods expect(componentInstance.counter(1)).toEqual(2); }); }); As you saw, you can access everything a component possess using shallow utitity. You can also have a look at the example test case in our boilerplate code here. Example Lets take an example of a component with state and class method. We will write test case for the methods including snapshot test. The example includes testing class methods, state and props. import React from 'react'; import renderer from 'react-test-renderer'; import {shallow} from 'enzyme'; import Counter from '../Counter.component'; describe('Counter component', () => { it('Counter: renders correctly', () => { const tree = renderer.create().toJSON(); expect(tree).toMatchSnapshot(); }); it('componentWillMount: should set the passed initialCountValue to state', () => { const wrapper = shallow(); expect(wrapper.instance().state.count).toBe(2); }); it('incrementCounter: should increment state.count by 1', () => { const wrapper = shallow(); const instance = wrapper.instance(); expect(instance.state.count).toBe(0); instance.incrementCounter(); expect(instance.state.count).toBe(1); }); it('decrementCounter: should decrement state.count by 1', () => { const wrapper = shallow(); const instance = wrapper.instance(); expect(instance.state.count).toBe(1); instance.decrementCounter(); expect(instance.state.count).toBe(0); }); it('should call props on increment/decrement', () => { const incrementSpy = jest.fn(); const decrementSpy = jest.fn(); const wrapper = shallow(); const instance = wrapper.instance(); instance.incrementCounter(); expect(incrementSpy).toBeCalledWith(2); instance.decrementCounter(); expect(decrementSpy).toBeCalledWith(1); }); }); Note: You can find this example working live here. "},"7-testing/7.4-mocking-rn-modules.html":{"url":"7-testing/7.4-mocking-rn-modules.html","title":"Mocking RN modules  ","keywords":"","body":"Mocking modules in Jest Like other testing frameworks, jest also supports mocking modules, both node_modules and custom JS modules. Most of the react-native specific utilities are automatically mocked for us(since we are using react-native preset). If you install any other modules which aren't automatically mocked(say a react-native module which has a dependency on NativeModules), you would need to mock the module manually. How do you manually mock While jest supports a bunch of methods for mocking utilities, we suggest doing manual mocks by creating a file with the same file name under __mocks__ folder adjacent to the module which we are mocking. ├── config ├── __mocks__ │ └── react-native-exception-handler.js ├── utils │ ├── __mocks__ │ │ └── language.util.js │ └── language.util.js └── node_modules As you can see above, you can mock both nodemodules and your custom defined JS files. Whenever you import utils/language.util file, jest will automatically read from `_mocks/language.util.js`. If you would like to un-mock a file and read the real source code instead of mocking it, you could do that using jest.unmock('module_path') function in the test case. Note: You can also use the automock feature of jest by using a function called jest.genMockFromModule Though it might not work for some of the modules which returns nested methods and it will only mock the functions which a module exports. Example of automock: Lets say you want to mock the functions exposed by a node module called react-native-exception-handler Since it is a nodemodule, we would need to put the mock file inside `_mocks/react-native-exception-handler`. Refer to the tree above to know where this file will lie To automock the module, our file would look something like this: __mocks__/react-native-exception-handler.js const mockedModule = jest.mock('react-native-exception-handler'); module.exports = mockedModule; If we wish to mock this module manually. We need to know what all functions a module exports and mock all of them separately. Our file would look something like this: __mocks__/react-native-exception-handler.js export default { setJSExceptionHandler: jest.fn(), getJSExceptionHandler: jest.fn(), setNativeExceptionHandler: jest.fn() }; Then in the jest file, we will say that we want to mock a module by doing: jest.mock('module_path'); NPM modules inside the mock folder residing adjacent to the node_modules are mocked by default hence we do not need to specifically mock them. To know more about the manual mocking in jest, please visit here. "},"8-styling/8.0-intro.html":{"url":"8-styling/8.0-intro.html","title":"Styling 💅🏻","keywords":"","body":"Styling in React Native In react native we use StyleSheets to write our styling. StyleSheets can be thought of something like a subset of CSS along with few additional helpers for RN. StyleSheets unlike CSS are pure JavaScript objects. This might confuse some web developers in the beginning and introduces a slight learning curve. StyleSheets in React Native are used somewhat similar to that of inline styles in web. Hence, you do not have access to pseudo classes like :hover,:active, etc. Example Imagine we want to add padding and border to a span. In CSS we will write: .button { padding: 10px; text-align: : center; border: 1px solid black; } and then we will add this class to our span like this: Test Resulting in : Test In React Native, there is no concept of pixels or classes. Instead, our sizes will be specified in \"units\" which will then be translated to pixels based on the pixel density of the screen automagically by RN. If we write the same View in a React Native StyleSheet, it would look something like this. styles.js import { StyleSheet } from 'react-native'; export default StyleSheet.create({ button: { padding: 10, textAlign: 'center', borderWidth: 1, borderColor: 'black' } }); and we will add styles to our View by: import styles from './styles.js'; ... ... ... Note that since we are writing JavaScript objects, immediately we notice that: We write each style in its camel-cased version of the CSS We then import our StyleSheet into our components and used them by declaring a style attribute as shown instead of classes. There are no shorthands like border:'1px solid black' Just like web, it is very easy to go wrong with CSS and end up with a style code that is unmanageable. Hence, we would like to introduce few basic guidelines in the next chapters, so that we can get most from our styles. "},"8-styling/8.1-theme-variables.html":{"url":"8-styling/8.1-theme-variables.html","title":"Theme Variables","keywords":"","body":"Theme Variables In general every app should have few fixed font sizes, colors, spacing, etc. This is done so that the app looks consistent across screens. Now this can be achieved by keeping a convention across the app. For example, the devs and UX designers can decide fontSize: 16 - Large 14 - Medium 12 - Small Hence our style sheet may look like this : styles.js import { StyleSheet } from 'react-native'; export default StyleSheet.create({ largeButtonText: { fontSize: 16, fontWeight: 'bold' }, largeHeaderText:{ fontSize: 16 }, mediumHeaderText: { fontSize: 14, color:'blue' } }); Even though this convention is good and will help you maintain consistency in small,medium and large text sizes across the app, it has few fundamental faults: Business/Marketing team may come up with a new requirement that now they want the large font size to be 18 instead of 16. Now as a developer, you will need to make changes in the entire app and replace every instance of fontSize:16 with fontSize:18, which kind of sucks!. A new developer who joined the team might not be aware of all the conventions followed by the team and may create a component with fontSize other than 12,14 or 16 thus accidently destroying the code standard/convention. Enter theme variables. In order to solve the above mentioned issues we introduce a common file theme.style.js which will be located at app/styles/theme.style.js. In the theme file we define our theme variables as follows: app/styles/theme.style.js export default { FONT_SIZE_SMALL: 12, FONT_SIZE_MEDIUM: 14, FONT_SIZE_LARGE: 16, PRIMARY_COLOR: 'rgb(30, 147, 242)', SECONDARY_COLOR: 'rgb(238, 167, 2)', FONT_WEIGHT_LIGHT: 200, FONT_WEIGHT_MEDIUM: 600, FONT_WEIGHT_HEAVY: 800 }; and we can use it like this styles.js import { StyleSheet } from 'react-native'; import theme from '../styles/theme.style.js'; export default StyleSheet.create({ largeButtonText: { fontSize: theme.FONT_SIZE_LARGE, fontWeight: theme.FONT_WEIGHT_HEAVY }, largeHeaderText:{ fontSize: theme.FONT_SIZE_LARGE }, mediumHeaderText: { fontSize: theme.FONT_SIZE_MEDIUM, color:theme.PRIMARY_COLOR } }); Now our theme file dictates the size of fonts and the primary color, etc. This gives us two benefits: If our business team now tell us to change the font sizes, we can change the theme variables at one place and it gets reflected in the entire app. This will enable us to write multiple theme files which inturn adds basic themeing support to our app. For example: we can write two theme files - one for light theme and one for dark theme and give our app users the option to switch the themes. Integrating theme variables into our NoteTaker demo Enough of the theory, lets try and inculcate this concept into our demo app. First of all add the file app/style/theme.style.js. app/style/theme.style.js export default { PRIMARY_COLOR: '#2aabb8', FONT_SIZE_SMALL: 12, FONT_SIZE_MEDIUM: 14, FONT_SIZE_LARGE: 16, FONT_WEIGHT_LIGHT: '200', FONT_WEIGHT_MEDIUM: '500', FONT_WEIGHT_BOLD: '700', BACKGROUND_COLOR_LIGHT: '#f0f6f7', CONTAINER_PADDING: 20 }; Now we need to modify our components to use the theme variables. Modify the following files: app/components/TextArea/TextArea.component.style.js import {StyleSheet} from 'react-native'; import theme from '../../styles/theme.style'; export default StyleSheet.create({ textArea: { fontSize: theme.FONT_SIZE_MEDIUM, fontWeight: theme.FONT_WEIGHT_LIGHT } }); app/components/Home/Home.component.js import React, {Component} from 'react'; import {View, Text} from 'react-native'; import styles from './Home.component.style'; import TextArea from '../TextArea/TextArea.component'; class Home extends Component { render () { return ( Please enter your note here ); } } export default Home; app/components/Home/Home.component.style.js import {StyleSheet} from 'react-native'; import theme from '../../styles/theme.style'; export default StyleSheet.create({ container: { flex: 1, paddingVertical: theme.CONTAINER_PADDING, alignItems: 'center' }, textAreaTitle: { fontSize: theme.FONT_SIZE_MEDIUM, fontWeight: theme.FONT_WEIGHT_BOLD, alignSelf: 'flex-start', padding: 10 }, textArea: { flex: 1, padding: theme.CONTAINER_PADDING, alignSelf: 'stretch', overflow: 'scroll', backgroundColor: theme.BACKGROUND_COLOR_LIGHT } }); Our app should now look like this: The code till here can be found on the branch chapter/8/8.1 "},"8-styling/8.2-common-styles-mixins.html":{"url":"8-styling/8.2-common-styles-mixins.html","title":"Common Styles/Mixins","keywords":"","body":"Common styles In React Native, each component is styled using inline styles. This means that it becomes slightly tricky to share styles as you can in web. In web we write a class .btn { padding: 10; border: '1px solid black'; } Now if we want to apply this class to two different divs we will do so as follows: First button Second button Now same is possible in react native as follows: styles.js import { StyleSheet } from 'react-native'; export default StyleSheet.create({ btn: { padding: 10, borderWidth: 1 }, firstBtn:{ ... ... }, secondBtn:{ ... ... } }); and we will add styles to our View by: import styles from './styles.js'; ... ... ... First button Second button While this solves the problem only if the style objects are in the same component because in RN we do not import styles from other components (each component has its own style). But in web, we could have just reused the class anywhere (since css is global). To solve the problem of reusable styles in React Native, we introduce another file named app/style/common.style.js This is where we will write our mixins / common styles. Hence,if all the buttons in our app have similar style we can write a style with the similar properties inside the common.style.js app/style/common.style.js import { StyleSheet } from 'react-native'; export default StyleSheet.create({ btn: { padding: 10, borderWidth: 1 } }); And we can just import this in our component style files and reuse them directly like this: styles.js import { StyleSheet } from 'react-native'; import common from '../style/common.style.js'; export default StyleSheet.create({ firstBtn:{ ...common.btn, backgroundColor: 'blue' }, secondBtn:{ ...common.btn, backgroundColor: 'red' } }); and we will add styles to our View like this: import styles from './styles.js'; ... ... ... First button Second button This way our mixins/common style file will provide us the base styles which are common across the app and we write component specific styles in the component style file. Thus allowing significant style reuse and avoiding code duplication. Integrating common/mixin styles into our NoteTaker demo Before we go into common styles , lets modify our code a bit to add another component for entering title for our note. Modify the following files as follows: app/components/Home/Home.component.js import React, {Component} from 'react'; import {View, Text, TextInput} from 'react-native'; import styles from './Home.component.style'; import TextArea from '../TextArea/TextArea.component'; class Home extends Component { state = { title: '' // adding the state here temporarily for illustration purposes } setTitle = (title) => this.setState({title}) render () { return ( Note Title Please type your note below ); } } export default Home; app/components/Home/Home.component.style.js import {StyleSheet} from 'react-native'; import theme from '../../styles/theme.style'; export default StyleSheet.create({ container: { flex: 1, paddingVertical: theme.CONTAINER_PADDING, alignItems: 'center' }, titleHeading: { fontSize: theme.FONT_SIZE_MEDIUM, alignSelf: 'flex-start', padding: 10, fontWeight: theme.FONT_WEIGHT_BOLD, }, titleTextInput: { padding: theme.TEXT_INPUT_PADDING, backgroundColor: theme.BACKGROUND_COLOR_LIGHT, alignSelf: 'stretch' }, textAreaTitle: { fontSize: theme.FONT_SIZE_MEDIUM, alignSelf: 'flex-start', padding: 10, fontWeight: theme.FONT_WEIGHT_LIGHT, fontStyle: 'italic' }, textArea: { padding: theme.TEXT_INPUT_PADDING, backgroundColor: theme.BACKGROUND_COLOR_LIGHT, alignSelf: 'stretch', flex: 1 } }); app/styles/theme.style.js export default { PRIMARY_COLOR: '#2aabb8', FONT_SIZE_SMALL: 12, FONT_SIZE_MEDIUM: 14, FONT_SIZE_LARGE: 16, FONT_WEIGHT_LIGHT: '200', FONT_WEIGHT_MEDIUM: '500', FONT_WEIGHT_BOLD: '700', BACKGROUND_COLOR_LIGHT: '#f0f6f7', CONTAINER_PADDING: 20, TEXT_INPUT_PADDING: 10 }; Our app should now look like this: If you notice, even though we have theme file, our style code has lot of duplicated code. Primarily because we are repeating our styling for text input and also for the heading. The solution to this problem as discussed before is common styles/ mixins Lets create the file common.style.js app/styles/common.style.js import theme from './theme.style'; export const headingText = { fontSize: theme.FONT_SIZE_MEDIUM, alignSelf: 'flex-start', padding: 10, fontWeight: theme.FONT_WEIGHT_BOLD, }; export const textInput = { padding: theme.TEXT_INPUT_PADDING, backgroundColor: theme.BACKGROUND_COLOR_LIGHT, alignSelf: 'stretch' }; And modify our component style files to include the common.style.js app/components/Home/Home.component.style.js import {StyleSheet} from 'react-native'; import theme from '../../styles/theme.style'; import {headingText, textInput} from '../../styles/common.style'; export default StyleSheet.create({ container: { flex: 1, paddingVertical: theme.CONTAINER_PADDING, alignItems: 'center' }, titleHeading: { ...headingText }, titleTextInput: { ...textInput }, textAreaTitle: { ...headingText, fontWeight: theme.FONT_WEIGHT_LIGHT, fontStyle: 'italic' }, textArea: { ...textInput, flex: 1 } }); If you see our style code looks much more consice and we are resuing the styles for similar components with slight style changes. Hence, we import our base styles for the components from common.style.js and add our custom styles later on top of it. This way we reduce our work and minimize code duplication. We see no change in the output but our code becomes much much cleaner. The code till here can be found on the branch chapter/8/8.2 "},"8-styling/8.3-separating-styles-from-component.html":{"url":"8-styling/8.3-separating-styles-from-component.html","title":"Separating styles from component","keywords":"","body":"Separating styles from component code Lets assume we want to build a Button component. A simple button will look something like this: Button.component.js import React, { Component } from 'react'; import { StyleSheet, Text, View} from 'react-native'; class Button extends Component { render() { return ( Press Me! ); } } const styles = StyleSheet.create({ container: { padding: 10, alignItems:'center', justifyContent:'center', backgroundColor: '#43a1c9', }, buttonText: { fontSize: 20, textAlign: 'center' } }); export default Button; This will produce a nice looking button component. But we suggest that you move the styles to a different file Button.component.style.js. Modifying the code we get. Button.component.js import React, { Component } from 'react'; import { StyleSheet, Text, View} from 'react-native'; import styles from './Button.component.style.js'; class Button extends Component { render() { return ( Press Me! ); } } export default Button; Button.component.style.js export default StyleSheet.create({ container: { padding: 10, alignItems:'center', justifyContent:'center', backgroundColor: '#43a1c9', }, buttonText: { fontSize: 20, textAlign: 'center' } }); This has few benefits: This makes the component code much cleaner. The style is present in its own separate file. This allows you two write two different style files for android and ios when needed. Thus you keep the same functionality but the button looks different as needed in two different platforms. For example: Button.component.js import React, { Component } from 'react'; import { StyleSheet, Text, View} from 'react-native'; import styles from './Button.component.style.js'; class Button extends Component { render() { return ( Press Me! ); } } export default Button; iOS specific style Button.component.style.ios.js export default StyleSheet.create({ container: { padding: 10, alignItems:'center', justifyContent:'center', backgroundColor: '#43a1c9', }, buttonText: { fontSize: 20, textAlign: 'center' } }); Android specific style Button.component.style.android.js export default StyleSheet.create({ container: { padding: 10, borderWidth: 1, alignItems:'center', justifyContent:'center', backgroundColor: '#d2843b' }, buttonText: { fontSize: 20, textAlign: 'center' } }); Thus by simply moving the styles into a separate file we could achieve a style code that behaves exactly the way we needed in different platforms. Also, we could reuse the component logic. Conclusion In Web, we have lots of production grade tools like Sass, Less, etc which allows us to write modular, scoped CSS which are easier to manage. These tools then take care of building all our style code into one cohesive stylesheet for our entire application. In React Native, we must think of styling in a slightly different manner. By doing some pre-planning and organization before writing the code for the components, we can reduce code duplication and unnecessary confusions. It takes a bit of getting used to, but styling in React Native is as powerful as the CSS for the web and is the fastest way to build multiplatform native applications. "},"9-redux/9.0-intro.html":{"url":"9-redux/9.0-intro.html","title":"Redux","keywords":"","body":"Redux - The State Container We assume that the reader is already aware of Redux. But just to refresh, according to redux.js.org: Redux is a predictable state container for JavaScript apps. It helps you write applications that behave consistently, run in different environments (client, server, and native), and are easy to test. On top of that, it provides a great developer experience, such as live code editing combined with a time traveling debugger. In a nutshell, redux is a state container. That is it will contain all our runtime application state or data. Redux essentially has a three parts: Store - Store contains a global state for the entire app. It is basically the manager for the application state. Actions - These are like the commands you pass to store along with some data to do some modifications to the stored state. Reducers - Reducers are basically functions that the store calls whenever a action arrives. The reducers are the ones which determines what the new state will be based on the actions and the action payload it receives. But we already have React's state Both Redux and React's state are used to manage the state in the application. But, both Redux and React's state are very different in the way they work and it is good to know when to use what. React state is stored locally within a component. When it needs to be shared with other components, it is passed down through the props. Hence, this means all the components which need the state data need to be the child of the component holding the value. But in case of Redux, state is stored globally in the Redux store. Components subscribe to the store to get access to the value. This centralizes all data but makes it very easy for a component to get the state it needs, without surrounding components knowing of its needs. So, this means that Redux is good and we should just use it for all our app state management. NO ! While redux is helpful in some cases, it will create unnecessary indirections for simpler and trivial use cases. Consider that we have a text input. And since we are using redux, we decide to use redux to store all the changes in the text field in redux. In redux for changing the state on text input, we will need to create an Action, write a reducer and then subscribe our component to the store so that it re renders on every state change. This is bad! Why so much complication? Dan Abramov - The creator of redux says you might actually not need redux unless you have a plan to benefit from this additional indirection. In his blog at https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367, he clearly states that since redux introduces an additional indirection to managing the state of the application, we should use it only if it benefits us. Now, lets see when we should use redux and when React's state is good enough. One way to do this is based on Duration of the data we want to store. As, Tyler Hoffman explains in his blog post https://spin.atomicobject.com/2017/06/07/react-state-vs-redux-state/, Different pieces of state are persisted for different amounts of time. We can categorize data into: Short term: data that will change rapidly in your app Medium term: data that will likely persist for a while in your app Long term: data that should last between multiple app launch. Short term data Short term data is something that changes very quickly and is needed to be stored only for small amount of time. For example, this includes the characters that the user types in a text field. This data is not needed once the user submits the form. Also we will not need to mostly transfer this type of data to any other independent component. Such type of data clearly fits the use case for React's state. Medium term data Medium term data needs to stick around while the user navigates the app. This could be data loaded from an API, or any changes that needs to be persisted up until a page refresh. This can also contain data that needs to be used by a component that is completely unrelated to the component that produced the data. As an example, consider that one of the component makes an API call on a button click to update user's profile details. The data returned from the server needs to be stored and will be used by a completely unrelated profile screen. Now, if the data is was stored in some global location. It would be far easier to access this data. Such type of use cases clearly fits Redux. Long term data This is the data that should be persisted between refreshes of the page or when the user closes and reopens the app. Since the Redux store is created on app launch, this type of data should be stored somewhere else, for example: Async Storage in the case of React Native. "},"9-redux/9.1-redux-setup.html":{"url":"9-redux/9.1-redux-setup.html","title":"Redux setup","keywords":"","body":"Setting up Redux for React Native Why redux ? Lets say in our note taker app. We need to add the character count and a save/sync button at bottom. First lets create the UI component for it. Modify the files app/components/Home/Home.component.js ... ... ... onChangeText={this.setTitle} value={this.state.title} /> Please type your note below Save {20} characters ); } app/components/Home/Home.component.style.js export default StyleSheet.create({ container: { flex: 1, paddingTop: theme.CONTAINER_PADDING, flexDirection: 'column', justifyContent: 'space-between' }, ... ... ... ... textArea: { ...textInput, flex: 1 }, bottomBar: { flexDirection: 'row', alignItems: 'center' }, bottomBarWrapper: { flexDirection: 'row', justifyContent: 'space-between', flex: 1 }, saveBtn: { padding: 10, fontWeight: theme.FONT_WEIGHT_BOLD }, characterCount: { padding: 10, fontSize: theme.FONT_SIZE_SMALL } }); app/styles/theme.style.js ... ... BACKGROUND_COLOR_LIGHT: '#ebe9e9', ... ... }; Now our app should have a bottom bar with character count and a save button. Currently we have hard coded the character count to 20. But if you look at the app now, there is no way for us to get the character count from the TextArea component and use it as the text for character count text view. To do this we will need to move the state present inside the TextArea component and place it in the Home component. This is because all the components that need access to a state have to be the child of the component holding the state. So we modify our components as follows: app/components/TextArea/TextArea.component.js import React, {Component} from 'react'; import {TextInput} from 'react-native'; import PropTypes from 'prop-types'; import styles from './TextArea.component.style'; class TextArea extends Component { static propTypes = { text: PropTypes.string, onTextChange: PropTypes.func } render () { const {text, onTextChange, ...extraProps} = this.props; return ( ); } } export default TextArea; app/components/Home/Home.component.js import React, {Component} from 'react'; import {View, Text, TextInput} from 'react-native'; import styles from './Home.component.style'; import TextArea from '../TextArea/TextArea.component'; class Home extends Component { state = { title: '', text: '' } setTitle = (title) => this.setState({title}) setText = (text) => this.setState({text}); render () { return ( Note Title Please type your note below Save {this.state.text.length} characters ); } } export default Home; The character count should now update whenever you enter text on the text field. Hence, here by moving the state from the child component to parent, we were able to access it in multiple child components. Thus, to provide access to the data that needs to be accessed by multiple components, we need to have the state in the enclosing parent component. Thus following this principle, if we keep on moving the state to the parent component, we will end up with a state present in the top most level component. Redux builds on top of similar principles. It keeps a global store to which the components which need access to the data can subscribe to. Additionally, it provides a mechanism by which these components can re-render whenever the data in the store changes. Now, since we are clear why redux is helpful. Lets setup redux for our app. Setup Lets begin by installing few packages. yarn add redux react-redux redux-promise redux-thunk or npm install --save redux react-redux redux - the main redux library. react-redux - the react bindings for redux, which makes our life easy when using redux with react. Additionally, you can also install your preferred redux middleware like redux-thunk, etc. The comments on the code specify how to do that. Now create the files app/redux/store.js import {createStore, compose/* , applyMiddleware*/} from 'redux'; // import someReduxMiddleware from 'some-redux-middleware'; // import someOtherReduxMiddleware from 'some-other-redux-middleware'; import rootReducer from './reducers/root.reducer'; const enhancerList = []; const devToolsExtension = window && window.__REDUX_DEVTOOLS_EXTENSION__; if (typeof devToolsExtension === 'function') { enhancerList.push(devToolsExtension()); } const composedEnhancer = compose(/* applyMiddleware(someReduxMiddleware, someOtherReduxMiddleware),*/ ...enhancerList); const initStore = () => createStore(rootReducer, {}, composedEnhancer); module.exports = { initStore }; app/redux/reducers/root.reducer.js import {combineReducers} from 'redux'; export default combineReducers({ }); Now, lets add our first reducer and action. Create the files: app/redux/actions/index.actions.js This file will contain all our actions. export const TEST_ACTION = 'TEST_ACTION'; app/redux/reducers/test.reducer.js import {TEST_ACTION} from '../actions/index.actions'; const test = (state = {}, action) => { switch (action.type) { case TEST_ACTION: { return action.payload; } default: return state; } }; export default test; Now lets add our test reducer to the root reducer. Modify app/redux/reducers/root.reducer.js import {combineReducers} from 'redux'; import test from './test.reducer'; export default combineReducers({ test }); Now lets initialize the store. Modify the file: app/index.js import React, {Component} from 'react'; import {initStore} from './redux/store'; import {Provider} from 'react-redux'; import App from './App.container'; const store = initStore(); class NoteTaker extends Component { render () { return ( ); } } export default NoteTaker; and move the Initialization of the home component to another file app/App.container.js import React, {Component} from 'react'; import Home from './components/Home/Home.component'; import {connect} from 'react-redux'; class App extends Component { render () { console.log(this.props.state); // eslint-disable-line return ( ); } } const mapStateToProps = (state) => ({ state }); const mapDispatchToProps = (dispatch) => ({ dispatch }); export default connect(mapStateToProps, mapDispatchToProps)(App); At this point, we should a have a redux store with an initial test state from the test reducer. To check this, lets run our app on the simulator. Now open up the debug menu on the iOS simulator by pressing cmd+ctrl+z or on Android emulator by using cmd+m. Choose Debug JS Remotely. This should run the app js code in react-native-debugger and if all went well we should see something like this on the console panel: This implies that our redux store successfully initialized with the test reducer. NOTE: If your tests fail due to the error window not defined, then add a mock file __mocks__/react-native.js var rn = require('react-native'); global.window = global; module.exports = rn; This will initialize a dummy window variable when tests are run in node environment. The code till here can be found on the branch chapter/9/9.1 "},"9-redux/9.2-presentational-vs-containers.html":{"url":"9-redux/9.2-presentational-vs-containers.html","title":"Presentational VS Containers","keywords":"","body":"Presentational Components VS Container Components When writing code in React or React Native, we often wonder how to structure our code so that it makes our life much easier with handling all state changes, data flow and renders, etc. There is a pattern which helps organizing React based applications - splitting the components into presentational and containers. Presentational components Presentational components are those components whose only job is to render a view according the styling and data passed to it. In essence they do not have any business logic in them. That is why they are sometimes also called 'dumb components'. This means that they don't have direct access to redux or other data stores. Data is passed onto them as props. According to Dan Abramov via his blog https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0, In a nutshell, presentational components: are concerned with how things look. have markup and styles of their own. Have no dependencies on the rest of the app, such as redux stores. don’t specify how the data is loaded or mutated. receive data and callbacks exclusively via props. rarely have their own state (when they do, it’s UI state rather than data). An example of a Dumb/Presentational component would be : import React, {Component} from 'react'; import {View} from 'react-native'; import styles from './Header.component.style'; class Header extends Component { render () { const {title, subtitle} = this.props; return ( {title} {subtitle} ); } } export default Header; Container components Container components are those React components which have access to the store. These components make api calls, do processing and contain the business logic of the app. Container components shouldn't have the view logic or presentational logic. The job of container component is to compute the values and pass them as props to the presentational components. Hence these components are sometimes also referred to as Smart Components. Hence, Container components: are concerned with how things work. don’t usually have any markup of their own except for some wrapping Views, and never have any styles. provide the data and behavior to presentational or other container components. call redux actions and provide these as callbacks to the presentational components. are often stateful, as they tend to serve as data sources. are usually generated using higher order components such as connect() from React Redux, createContainer() from Relay, or Container.create() from Flux Utils, rather than written by hand. An example of Smart/Container component would be: import React, {Component} from 'react'; import Header from '../component/Header.component'; class Home extends Component { calculateSomething = () => { ...some calculation / api calls.... } render () { const {title, subtitle, goToLogin} = this.props; return ( ); } } const mapStateToProps = (state)=>{ return { title: state.title, subtitle: state.subtitle }; }; const mapDispatchToProps = (dispatch) => { goToLogin: () => dispatch({action:'GO_TO_LOGIN'}) }; export default connect(mapStateToProps, mapDispatchToProps)(Home); In the above example, if you notice our Container components do not do any kind of layouting or styling. It only manages the business logic. This helps us separate the concerns \"Styling/Layouting\" and \"Business Logic\". The Container-Presentational pattern gives us many benefits: Less code duplication. Because you are now forced to move all the layout components out as separate presentational components, you can now directly reuse them instead of copy-pasting the code in every page. Presentational components are essentially your app’s View layer. Hence, you can change the styling without touching the app's logic. Better separation of concerns. You understand your app and your UI better by writing components this way. Better reusability. You can use the same presentational component with completely different state sources, and turn those into separate container components that can be further reused. Back to Code Lets organize our project to include presentational and container components pattern. First lets add a new reducer to manage our content (title and text). Modify the action file to include these: app/redux/actions/index.actions.js import {createAction} from 'redux-actions'; export const TEST_ACTION = 'TEST_ACTION'; export const SET_TEXT = 'SET_TEXT'; export const SET_TITLE = 'SET_TITLE'; export const setTitle = createAction(SET_TITLE); /* This is equivalent to export const setTitle = (payload) => { return { type: SET_TITLE, payload: payload }; }; */ export const setText = createAction(SET_TEXT); Notice the use of createAction. As the comment says: We are essentially replacing: export const setTitle = (payload) => { return { type: SET_TITLE, payload: payload }; }; with export const setTitle = createAction(SET_TITLE); To do this we need to include another package yarn add redux-actions Now, lets create the corresponding reducer app/redux/reducers/content.reducer.js import {SET_TEXT, SET_TITLE} from '../actions/index.actions'; const defaultState = { text: '', title: '' }; const content = (state = defaultState, action) => { switch (action.type) { case SET_TEXT: { return {...state, text: action.payload}; } case SET_TITLE: { return {...state, title: action.payload}; } default: return state; } }; export default content; Now, lets add the reducer to the root reducer. app/redux/reducers/root.reducer.js import {combineReducers} from 'redux'; import test from './test.reducer'; import content from './content.reducer'; export default combineReducers({ test, content }); Finally, its time to create our first Smart component. Create a new file under /pages with the name Home.page.js app/pages/Home.page.js import React, {Component} from 'react'; import PropTypes from 'prop-types'; import {connect} from 'react-redux'; import {setTitle, setText} from '../redux/actions/index.actions'; import Home from '../components/Home/Home.component'; class HomePage extends Component { render () { const {setTitle, setText, title, text} = this.props; return ( ); } } HomePage.propTypes = { setTitle: PropTypes.func, setText: PropTypes.func, title: PropTypes.string, text: PropTypes.string }; const mapStateToProps = (state) => ({ title: state.content.title, text: state.content.text }); const mapDispatchToProps = (dispatch) => ({ setTitle: (title) => dispatch(setTitle(title)), setText: (text) => dispatch(setText(text)), }); export default connect(mapStateToProps, mapDispatchToProps)(HomePage); If you notice the job of Home Page is just to fetch data and provide logical functions to the view layer. The corresponding view layer would look like this: app/components/Home/Home.component.js import React, {Component} from 'react'; import {View, Text, TextInput} from 'react-native'; import styles from './Home.component.style'; import TextArea from '../TextArea/TextArea.component'; import PropTypes from 'prop-types'; class Home extends Component { render () { const {setTitle, title, text, setText} = this.props; return ( Note Title Please type your note below Save {text.length} characters ); } } Home.propTypes = { setTitle: PropTypes.func, setText: PropTypes.func, title: PropTypes.string, text: PropTypes.string }; export default Home; Finally lets modify our app container to include the page instead of the component. app/App.container.js import React, {Component} from 'react'; import Home from './pages/Home.page'; import {connect} from 'react-redux'; class App extends Component { render () { return ( ); } } export default connect(null, null)(App); Finally our app should look like this: Although the app looks exactly the same, it is working in a slightly different manner. If you paid attention you would notice: Now we have clear demarkation between view and logic layer. Hence if UI breaks we know where to see and if logic breaks we know where to see. We are not importing react-native at all in any part of the whole code base except app/components/. This means porting the project to any other platform like electron is just rewriting app/components directory.The logical layer remains intact. Easier to maintain as the flow of data to view layer happens via props. The code till here can be found on the branch chapter/9/9.2 "},"10-navigation/10.0-intro.html":{"url":"10-navigation/10.0-intro.html","title":"Navigation","keywords":"","body":"Navigation Navigation in react-native is pretty different, specially if you are coming from web background. It follows native standards for navigation. Example: Screens, stacks, push/pop, which most of us web developers have not used for routing. It is not as simple as doing dispatch(push(''). You have to manage screens, reset your stack, nest them properly. If not configured well, it can cause huge performance loss and muliple components being mounted at a single point of time. React-native has a bunch of options for routing. (They have mentioned it here: https://facebook.github.io/react-native/docs/navigation.html). We found React-navigation the most stable among all the options. Why react-navigation? It is a wrapper over NavigationExperimental(which supports the smooth native-thread animations provided by the Animated library). Moreover, NavigationExperimental is removed from the latest react-native version because some libraries sprung up around it which made it much easier to use than the official implementation. The official react-native documentation suggests React-navigation. You will probably want to use React Navigation.: Says the documentation It supports native transitions for both android and IOS. Both android and IOS routes can be handled by one single configuration file without any platform specific configuration. Provides multiple type of navigators out of the box. eg: StackNavigator, TabNavigator, DrawerNavigator. It is highly configurable, you can configure almost everything. Again, using a single config file. Be it tabs, header, footer. Redux integration available: Its very easy to integrate with redux store. The benefit of this is that you can navigate by just dispatching action and passing route name. It makes route management much more easier. After integration, all you need to do is: dispatch(NavigationActions.navigate({routeName})). "},"10-navigation/10.1-using-react-navigation.html":{"url":"10-navigation/10.1-using-react-navigation.html","title":"Using React-navigation","keywords":"","body":"Using React-navigation Using react-navigation is pretty simple once you understand how it works. Unfortunately, their official documentation lacks some explanations. But no need to worry, we will try to fill the gaps in the official documentation in this chapter. The URL for official documentation: https://reactnavigation.org/docs/intro/ How navigation happens in native applications? When it comes to native apps, the routing is a little different, specially for those who are coming from a WEB development background. There is the concept of stack, screen, etc. What is a stack in navigation? We all have heard of stacks in our college programming classes. Well, this stack is exactly that. Whenever you navigate from one screen to another, the new screen comes on top. The old screen is still there(unless you reset your stack). This mechanism of caching the old pages helps improving performance and making the transitions smoother. Have a look at the below image for example of stack in navigation. Types of navigators offered by react-navigation React-navigation offers a bunch of navigators predefined for our use. An app might contain all the three navigators. Lets try to understand all of them one-by-one. Stack-navigator: This is most common navigator of all. You will use it for most of the applications. We just explained how stack works in navigation. You define stack navigator by passing the routes object inside StackNavigator function from react-navigation. Each of the screen gets mounted only when you navigate to that particular screen and gets un-mounted only when you go back or manually reset the navigation state. Tab-navigator: This is also quite common user interface. Where we have a bunch of tabs and we can swipe between them. We have seen this is facebook, twitter and many other famous apps. react-navigation supports this navigator as well out of the box. The way of defining is pretty much same as of stack-navigator. Only difference is that the routes you define in Tab-navigator gets mounted all at once. So you need to be a little careful when you manage navigating-to/coming from different stack. DrawerNavigator: //TODO Creating a router Install react-navigation using NPM or Yarn. yarn add react-navigation or npm install react-navigation --save Creating a router is pretty easy, you just define a page component(which will be container component) and then import in your router.js file. Each of the navigators accept an object while initialization whose syntax is as follows: const Router = StackNavigator({ : {screen: , navigationOptions: } }, { navigationOptions: }) routeNameis the name associated with the current scteen. It will be used for navigation/analytics tracking. screenObject The screen key in the router object can take: A react native component. An react-navigation router instance if you want routers nesting. Nesting of routers Example routes/index.js const AboutRoutes = TabNavigator({ aboutApp: { screen: AboutApp, }, aboutDevs: { screen: AboutDevs, } }); const Router = StackNavigator({ home: {screen: HomePage, navigationOptions: { title: 'Start taking notes', } }, about: { screen: AboutRoutes } }, { mode: 'card' }); export default Router; Each of the navigator returns a react component which is supposed to be added to the root level of the app. Example App.container.js import React, {Component} from 'react'; import Router from './routes'; import {connect} from 'react-redux'; class App extends Component { render () { return ( ); } } export default App; When we define a react component in our router file, it adds few properties to the component, which are: static navigationOptions: We can use this to define our headers, title, etc. However we recommend defining this in router.js because we will be importing page to our router and defining header UI/title in the container component is not a good idea. this.props.navigation: react-navigation also adds navigation function to the screen. This function can be used to navigate to a route or pass parameters. We do not recommend this way as we will be handling routing via redux-actions The code till here can be found on the branch chapter/10/10.1 "},"10-navigation/10.2-integrating-with-redux-store.html":{"url":"10-navigation/10.2-integrating-with-redux-store.html","title":"Integrating with redux store","keywords":"","body":"Integrating with redux store react-navigation comes with the ability to integrate with redux. Though it is optional, we highly recommend this. Before reading this chapter, please make sure that you have a basic understanding of react-navigation. If not, please have a look at this. Why redux integration? react-navigation maintains its internal store to keep track of stacks, routes history etc. if not configured to redux store. This was done so that it is easy to configure the library and there might be use cases when the app doesn't use redux or store linking is not required. After installing the library and configuring routes, you will se something like this on the debugger when you navigate. As you can see, the library maintains its own store and it logs every action in the dev mode. The library also has a flexibility to integrate itself the the redux store of your application. While the integration is completely optional, we highly recommend you doing this if your app is already using redux because of the following reasons: It gives as a lot more flexibility to control the route state at every point of time. Consider a case where you want to call a function on every route change. You can use redux middleware for screen tracking. It makes the navigation much more readable and cleaner. You just have to dispatch an action with the routeName where you want to navigate. It removes the dependency of react component to be able to navigate. Consider a scenario where you want to navigate from your thunk or saga file. How do you integrate navigation to the store? Integration with redux store is pretty easy. Lets continue the integration in our NoteTaker app by two simple steps. In your reducer's index file, add the reducer using getStateForAction function. reducers/index.js import {combineReducers} from 'redux'; import test from './test.reducer'; import Router from '../../routes'; const nav = (state, action) => ( Router.router.getStateForAction(action, state) || state; ); export default combineReducers({ test, nav }); In your App.container.js file, where the Router component is being imported, pass navigation prop with dispatch and nav state. The new app container file will look something like this: App.container.js class App extends Component { render () { const {dispatch, nav} = this.props; return ( ); } } const mapStateToProps = ({nav}) => ({ nav }); const mapDispatchToProps = (dispatch) => ({ dispatch }); After the integration you will be able to see the navigation state and actions inside your debugger's store. Using redux actions to navigate Since we are done with the redux integration, lets test now if the integration actually works and we are able to navigate by just dispatching an action. Lets refactor our Home.page.js file to dispatch an action on About button click instead of using this.props.navigation. Home.page.js import {connect} from 'react-redux'; import {NavigationActions} from 'react-navigation'; class HomePage extends Component { render () { return ; } } const mapDispatchToProps = (dispatch) => ({ onAboutPress: () => { dispatch(NavigationActions.navigate({routeName: 'about'})); } }); export default connect(null, mapDispatchToProps)(HomePage); And Voila!, it works like a charm. As you can see above, we are dispatching an action to navigate to about page. You might be wondering what's NavigationActions.navigate. Well its just an action creator which dispatches an action with type \"Navigation/NAVIGATE\". Passing route params If you need to pass some parameters to the next route, you could do so using params key. Example: dispatch(NavigationActions.navigate({routeName: 'about', params: {someKey: 'someValue'}})); You can access the passed params in the page using this.props.navigation.state.params inside the page file. About.page.js import result from 'lodash/result'; class AboutPage extends Component { render () { const navigatingFrom = result(this.props, 'navigation.state.params.navigatingFrom', ''); return ( About View {navigatingFrom ? Navigating from: {navigatingFrom} : null} ); } } Gotchas Here are some gotchas which you might face: You only have access to the routes defined in the current stack while navigating. If you try to navigate to a sibling stack from a nested page, you will face an error. To achieve this, you would need to goBack from the index screen of the current stack and then go to the screen where you want to navigate or use reset action creator. If you wish to add analytics/screen tracking, use redux-middleware defined here. Otherwise you could also use redux-ga-screen-tracker NPM module, which does Google analytics screen tracking automatically. Note: navigation-actions provides us with a lot of other action-creators as well such as back, reset, etc. Please have a look here to know all of them. The code till here can be found on the branch chapter/10/10.2 "},"10-navigation/10.3-file-structure-for-routes.html":{"url":"10-navigation/10.3-file-structure-for-routes.html","title":"File Structure for routes","keywords":"","body":"File Structure for routes As we add more and more routes, our router file tends to become huge and unmanageable. The index.js file will be containing styles defining the spacing of tabs, fontSize, etc and at the same time defining types of nested stacks and their screens. This file can become unmanageable in a very short time. Hence we split the files into multiple files, each defining its own stack and importing style from a separate file. Splitting your index.js file to multiple router files The current index.js looks something like this: routes/index.js const AboutRoutes = TabNavigator({ aboutApp: { screen: AboutApp, navigationOptions: { title: 'About the App' } }, aboutDevs: { screen: AboutDevs, navigationOptions: { title: 'About the Creators' } } }, { tabBarOptions: { upperCaseLabel: false, showIcon: false }, swipeEnabled: true, ..., animationEnabled: true }); const Router = StackNavigator({ home: {screen: HomePage, navigationOptions: { title: 'Start taking notes', } }, about: { screen: AboutRoutes } }); export default Router; As we can see, the current file defines two stacks, AboutRoutes, and the main Router. Lets create a new file which will contain just the screens required for about page and import it in routes/index.js file. routes/index.js import AboutRoutes from './about.routes.js'; const Router = StackNavigator({ home: {screen: HomePage, navigationOptions: { title: 'Start taking notes', } }, about: { screen: AboutRoutes } }); export default Router; routes/about.routes.js export default TabNavigator({ aboutApp: { screen: AboutApp, navigationOptions: { title: 'About the App' } }, aboutDevs: { screen: AboutDevs, navigationOptions: { title: 'About the Creators' } } }, { tabBarOptions: { upperCaseLabel: false, showIcon: false }, swipeEnabled: true, ..., animationEnabled: true }); Pretty neat huh? We can further modularize it such that all the navigation config data comes from a different file. This way, there will be a single file containing navigation config for all the routes. We can even reuse some of the configs. Taking out config data from routes file Lets take out the configuration file from our AboutRoutes. config/routes.config.js export const aboutRoutesConfig = { tabBarOptions: { upperCaseLabel: false, showIcon: false }, swipeEnabled: true, animationEnabled: true }; routes/about.routes.js import {aboutRoutesConfig} from '../config/router.config'; export default TabNavigator({ aboutApp: { screen: AboutApp, navigationOptions: { title: 'About the App' } }, aboutDevs: { screen: AboutDevs, navigationOptions: { title: 'About the Creators' } } }, aboutRoutesConfig); The router file looks much more cleaner now, defining just the routes and their title. In future if we need to change the config, we need not to go inside each route file and search for its config. The code till here can be found on the branch chapter/10/10.3 "},"11-devops/11.0-devops.html":{"url":"11-devops/11.0-devops.html","title":"DevOps","keywords":"","body":"DevOps Whenever we start a new project, after setting up the boilerplate, best practices suggest that we setup the continuous deployment so that the rest of the team could easily trigger and receive test builds of the latest app code. This way the testing team can easily receive the test builds without continuously bugging the developers. Few basic requirements for a good devOps setup can be: Lint and tests with coverage should run whenever a pull request is raised. Every time we merge our changes to the master branch we want the CI process to build the code, run lint and tests, and then build and publish apps to be distributed to the internal team testers. Each test build must have the a version and build number and it must be same on both Android and IOS for each version of code. An email should be sent out to all testers when a new build is available. Developers should also have the option to manually build on local machine quickly. Ability to pass environment vairables to the scripts so that we can generate different builds for staging, preprod and production. The following chapters would show step by step on how to achieve these. "},"11-devops/11.1-android-build-setup.html":{"url":"11-devops/11.1-android-build-setup.html","title":"Android Build setup","keywords":"","body":"Android build scripts / setup In android builds are done via gradle. These are the few pre-requisites to build a release apk. BUILD_NAME - The name that will be used by testers to identify the build, for example: '1.1.1', '1.0-alpha, etc. BUILD_NUMBER - A unique integer number identifying the build. This is used by android to identify which build is the updated build. This should be a integer number. for example : 1, 111, 111, etc. ANDROID_APP_ID - This is the unique app identifier which is used to identify the app uniquely in the play store or can be used to identify if the build is dev, pre prod or prod. These may look like these : com.app.notetaker-dev, com.app.notetaker-alpha. ANDROID_KEYSTORE_FILE - This is the keystore file used to sign the app. ANDROID_KEYSTORE_PASSWORD - This is the keystore password used while creating the keystore. ANDROID_KEY_ALIAS - This is key alias used to create the keystore. ANDROID_KEY_PASSWORD - This is the key password set for the key. Ideally every app has three release variants just like a typical backend application: Dev build - The app which connects to the staging/dev backend Environment. This can also have additional libraries like test fairy. Pre Prod build - The app which points to pre prod backend environment.This is usually very similar, if not identical to production app. Prod build - The final apk which should be released to the play store. Hence, we would need three different key stores for three different variants. Lets get started. First step is to create a new keystore file. Use the following command to create a keystore. keytool -genkey -v -keystore dev_release.keystore -alias dev-alias -keyalg RSA -keysize 2048 -validity 10000 You would be prompted to enter ANDROID_KEYSTORE_PASSWORD, ANDROID_KEY_ALIAS, ANDROID_KEY_PASSWORD and few other details. Note these down somewhere and keep the keystore file safe. The android documentation has the following warning: Note about saving the keystore: Once you publish the app on the Play Store, you will need to republish your app under a different package name (losing all downloads and ratings) if you want to change the signing key at any point. So backup your keystore and don't forget the passwords. For the build to work the keystore file should be placed at android/app/dev_release.keystore. Make sure the keystore file is git ignored so that you dont checking the file into git Now, create the following script. scripts/android/builder.sh #!/bin/bash set -e cur_dir=`dirname $0` echo \"BUILDING ANDROID\"; cd $cur_dir/../../android && ./gradlew clean assembleRelease -PBUILD_NAME=$BUILD_NAME -PBUILD_NUMBER=$BUILD_NUMBER -PANDROID_APP_ID=$ANDROID_APP_ID -PMYAPP_RELEASE_STORE_FILE=$ANDROID_KEYSTORE_FILE -PMYAPP_RELEASE_KEY_ALIAS=$ANDROID_KEY_ALIAS -PMYAPP_RELEASE_STORE_PASSWORD=$ANDROID_KEYSTORE_PASSWORD -PMYAPP_RELEASE_KEY_PASSWORD=$ANDROID_KEY_PASSWORD && cd .. echo \"APK will be present at android/app/build/outputs/apk/app-release.apk\" Apart from this script we would need to modify: android/app/build.gradle ... ... def enableProguardInReleaseBuilds = false ... ... def appID = System.getenv(\"ANDROID_APP_ID\") ?: \"com.notetaker\" def vCode = System.getenv(\"BUILD_NUMBER\") ?: \"0\" def vName = System.getenv(\"BUILD_NAME\") ?: \"1.0.local\" android { compileSdkVersion 23 buildToolsVersion \"23.0.1\" defaultConfig { applicationId appID minSdkVersion 16 targetSdkVersion 22 versionCode Integer.parseInt(vCode) versionName vName ndk { abiFilters \"armeabi-v7a\", \"x86\" } } ... ... ... signingConfigs { release { if (project.hasProperty('MYAPP_RELEASE_STORE_FILE')) { storeFile file(MYAPP_RELEASE_STORE_FILE) storePassword MYAPP_RELEASE_STORE_PASSWORD keyAlias MYAPP_RELEASE_KEY_ALIAS keyPassword MYAPP_RELEASE_KEY_PASSWORD } } } buildTypes { release { minifyEnabled enableProguardInReleaseBuilds proguardFiles getDefaultProguardFile(\"proguard-android.txt\"), \"proguard-rules.pro\" signingConfig signingConfigs.release } } ... ... ... The above script tells gradle to do clean build a release apk Also all the important parameters are passed via environment variables. This ensures that we can: Build the apk manually by running BUILD_NAME=1.1.1 BUILD_NUMBER=11 ANDROID_APP_ID='com.test.appid' ANDROID_KEYSTORE_FILE='dev_release.keystore' ANDROID_KEY_ALIAS='dev-alias' ANDROID_KEYSTORE_PASSWORD= ANDROID_KEY_PASSWORD= sh ./scripts/android/builder.sh Setup the environment variables in CI platform so that the CI can build the apk without manual intervention. Keep in mind that typically every CI provides a unique build number that you can pass to the script for BUILD_NUMBER. Woot! Its that simple to build a release apk for android. The built apk can be found at: android/app/build/outputs/apk/app-release.apk Note: For Windows users: If you are running Windows 10 64bit or higher you can enable Ubuntu bash shell on your systems and gain access to full bash command line and run the script there. More on that here : https://www.howtogeek.com/249966/how-to-install-and-use-the-linux-bash-shell-on-windows-10/ Or you could install Cygwin on your system and run the scripts mentioned. The code till here can be found on the branch chapter/11/11.1 "},"11-devops/11.2-ios-build-setup.html":{"url":"11-devops/11.2-ios-build-setup.html","title":"iOS Build setup","keywords":"","body":"iOS build scripts / setup [WIP] iOS builds via commandline are fairly much more complex as compared to android. These are the few pre-requisites to build a release ipa file. BUILD_NAME - The name that will be used by testers to identify the build, for example: '1.1.1', '1.0-alpha, etc. BUILD_NUMBER - A unique integer number identifying the build. This is used by android to identify which build is the updated build. This should be a integer number. for example : 1, 111, 111, etc. IOS_APP_ID - This is the unique app identifier which is used to identify the app uniquely in the app store or can be used to identify if the build is dev, pre prod or prod. These may look like these : com.app.notetaker-dev, com.app.notetaker-alpha. IOS_CERTIFICATE - This is the certificate file used to sign the app. IOS_CERTIFICATE_KEY - This is the certificate password used while creating the certificate. IOS_PROVISION_PROFILE - This is provision profile needed to build the app. This file mentions the capabilities / devices that are allowed to run the app. IOS_EXPORT_OPTIONS_PLIST - This is the options file needed to specify parameters for the build. IOS_SCHEME - The scheme which should be used to build the ipa. Typically we will have different schemes per environment. For example: we can have local, preprod and a production scheme. IOS_CONFIGURATION - This is the setting which specified if the build is DEBUG or RELEASE. PROJECT_NAME - This is name of the project for example if your project name inside ios folder says SampleProject.xcworkspace or SampleProject.xcodeproj, then PROJECT_NAME=SampleProject . Ideally every app has three release variants just like a typical backend application: Dev build - The app which connects to the staging/dev backend Environment. This can also have additional libraries like test fairy. Pre Prod build - The app which points to pre prod backend environment.This is usually very similar, if not identical to production app. Prod build - The final ipa which should be released to the app store. Hence, we would need three different schemes for three different variants. A typical build process in iOS would have following steps: Getting the certificates and provisioning profiles from apple developer account. Adding the certificate to the default keychain and placing the provisioning profile at the location ~/Library/MobileDevice/Provisioning\\ Profiles/ Archiving the project - Think of it as a executable zip of the project that can be run using XCode. Exporting the IPA - Think of it as exporting the archive to a format recognised by the iPhone. Lets get started Place the provisioning profile at scripts/ios/profile/XYZ.mobileprovision Place the certificate at scripts/ios/certs/ABC.p12 Place an exportOptions file at scripts/ios/exportOptions/exportOptions-dev.plist Typically an exportOptions file looks like this : scripts/ios/exportOptions/exportOptions-dev.plist compileBitcode method enterprise teamID ABC1234DA uploadBitcode uploadSymbols manifest appURL null displayImageURL null fullSizeImageURL null Make sure you put all the above files in the git ignore. Create the script: The below script will create a new keychain ios-build and will store the certificate in the keychain. Also, it will make the keychain the default one so that the xcode picks up the certificate from the new keychain. Then it will copy the provisioning profile in the correct directory so that xcode picks it up. scripts/ios/keychain.sh #!/bin/bash set -e cur_dir=`dirname $0` #Check if ios-build keychain exists export keychainCount=`security list-keychains | grep -E 'ios-build' -c` if [ $keychainCount == 0 ] ; then echo \"Create ios-build keychain\" # Create a custom keychain security create-keychain -p \"ios-build-password\" ios-build.keychain fi # Add it to the list security list-keychains -d user -s ios-build.keychain echo \"Making the ios-build keychain default ,so xcodebuild will use it for signing\" security default-keychain -s ios-build.keychain echo \"Unlocking the ios-build keychain\" security unlock-keychain -p \"ios-build-password\" ios-build.keychain # Set keychain timeout to 1 hour for long builds # see http://www.egeek.me/2013/02/23/jenkins-and-xcode-user-interaction-is-not-allowed/ security set-keychain-settings -t 3600 -l ~/Library/Keychains/ios-build.keychain echo \"Importing $IOS_CERTIFICATE to keychain\" security import $cur_dir/certs/$IOS_CERTIFICATE -k ~/Library/Keychains/ios-build.keychain -P $IOS_CERTIFICATE_KEY -T \"/usr/bin/codesign\" -A #Mac OS Sierra https://stackoverflow.com/questions/39868578/security-codesign-in-sierra-keychain-ignores-access-control-settings-and-ui-p security set-key-partition-list -S apple-tool:,apple: -s -k \"ios-build-password\" ios-build.keychain # Put the provisioning profile in place echo \"Coping $IOS_PROVISION_PROFILE in place\" mkdir -p ~/Library/MobileDevice/Provisioning\\ Profiles cp \"$cur_dir/profile/$IOS_PROVISION_PROFILE\" ~/Library/MobileDevice/Provisioning\\ Profiles/ Create the script that does the build. This script will run the xcodebuild to first archive the project. Then it will generate the IPA file that can be used for installing the app onto an iPhone. scripts/ios/builder.sh #!/bin/bash set -e cur_dir=`dirname $0` WORKING_DIR=`pwd`; cd $cur_dir/../../ios echo \"Setting version to ${BUILD_NUMBER}, ${BUILD_NAME}\" xcrun agvtool new-version -all ${BUILD_NUMBER} xcrun agvtool new-marketing-version ${BUILD_NAME} cd $WORKING_DIR echo \"Archiving the project\" xcodebuild clean archive PRODUCT_BUNDLE_IDENTIFIER=${IOS_APP_ID} -project $cur_dir/../../ios/${PROJECT_NAME}.xcodeproj -scheme $IOS_SCHEME -configuration $IOS_CONFIGURATION -derivedDataPath $cur_dir/../../ios/build -archivePath $cur_dir/../../ios/build/Products/${PROJECT_NAME}.xcarchive # or if you are not using xcodeproj and are using xcworkspace to build.. use the below code: # echo \"Archiving the project\" # xcodebuild clean archive PRODUCT_BUNDLE_IDENTIFIER=${IOS_APP_ID} -workspace $cur_dir/../../ios/${PROJECT_NAME}.xcworkspace -scheme $IOS_SCHEME -configuration $IOS_CONFIGURATION -derivedDataPath $cur_dir/../../ios/build -archivePath $cur_dir/../../ios/build/Products/${PROJECT_NAME}.xcarchive #SIGN # Issue : \"No applicable devices found.\" # Fix: https://stackoverflow.com/questions/39634404/xcodebuild-exportarchive-no-applicable-devices-found unset GEM_HOME unset GEM_PATH echo \"Export archive to create IPA file using $IOS_EXPORT_OPTIONS_PLIST\" xcodebuild -exportArchive -archivePath $cur_dir/../../ios/build/Products/${PROJECT_NAME}.xcarchive -exportOptionsPlist $cur_dir/../../scripts/ios/exportOptions/$IOS_EXPORT_OPTIONS_PLIST -exportPath $cur_dir/../../ios/build/Products/IPA echo \"IPA will be found at $cur_dir/../../ios/build/Products/IPA/$IOS_SCHEME.ipa\" Executing the scripts Run the keychain.sh to setup the certificate and provision profile like this: IOS_CERTIFICATE='ABC.p12' IOS_CERTIFICATE_KEY='PASSWORD' IOS_PROVISION_PROFILE='ABC.mobileprovision' sh scripts/ios/keychain.sh Now, run the build script to build the ipa file like this: PROJECT_NAME='NoteTaker' IOS_APP_ID='com.notetaker.app.ios' BUILD_NUMBER=11 BUILD_NAME=1.1.1 IOS_SCHEME='local' IOS_CONFIGURATION='RELEASE' IOS_EXPORT_OPTIONS_PLIST='exportOptions-dev.plist' sh ./scripts/ios/builder.sh The build should take couple of minutes and you can find the final ipa file at: ios/build/Products/IPA/ Note: Build works only for Mac users: Since apple requires that all the build be made on xcode itself, iOS apps can only be built on a mac machine. The code till here can be found on the branch chapter/11/11.2 "},"12-svg-icons-using-react-native-vector-icons/12.0-intro.html":{"url":"12-svg-icons-using-react-native-vector-icons/12.0-intro.html","title":"SVG Icons using react-native-vector-icons","keywords":"","body":"Icons in react-native Those who come from web development background knows the power of svg icons. We always prefer svg(for icons, images) and what not. Benefits of SVGs are: They are resolution independent(scalable) They provide you more flexibility in changing color etc. They are lesser in size as compared to an image. They are written in XML syntax so you can put directly inside your html without worrying about bundling your assets. That was about web, does react-native support SVGs? Unfortunately, rendering SVGs in native is not as simple as it is in HTML/WEB, where you can just use SVG as image IMG or copy paste svg content inside your HTML. Unlike web, react-native doesn't support SVGs out of the box. Though there are some plugins which lets you render SVGs, but they do not support all SVG elements and it is not very easy to use. How do you get the power of SVG in native environment? Let me introduce you to this amazing library called [react-native-vector-icons](https://github.com/oblador/react-native-vector-icons. It comes bundled with a bunch of icon sets(default is FontAwesome). All the fonts are scalable and you can style them just like SVGs. It returns a react component which accepts name, etc. as prop. After integration, the usage will be as simple as You can pass custom style. It also supports a couple of other components which might be useful. Ex, Button with an icon () You can also create your own iconset if you want to use custom icons. Installation is a 2 step process if you wish to use the icons provided by FontAwesome or other similar font libraries. (yarn add and react-native link) If you wish to use custom fonts(made in svg), please read the next chapter. "},"12-svg-icons-using-react-native-vector-icons/12.1-creating-custom-iconset.html":{"url":"12-svg-icons-using-react-native-vector-icons/12.1-creating-custom-iconset.html","title":"Custom Icon set","keywords":"","body":"Creating custom iconset react-native-vector-icons support using custom icon sets if you do not want to use the icons which come bundled or if you want to add your own icons. It supports Fontello and IcoMoon to create custom fonts. We used icomoon to convert our svgs to a config which is readable by the library. Setting up the framework Install the NPM module using NPM or Yarn. npm install --save react-native-vector-icons OR yarn add react-native-vector-icons Configuring your project to support custom iconsets. We will use IcoMoon to support custom icons/fonts. Icomoon is free and open source application which lets you convert a set of svg icons to fonts. It is a front end only app and does not upload your icons anywhere, so no privacy concerns! The steps for the configuration are as follows: Create a resources folder where we will keep our custom fontfile(.ttf). Do react-native link react-native-vector-icons. This will setup the vector icons framework for you. That's it, you are done with the setup. Now we need to get the ttf file and place it inside the resources/fonts that we just created. How to generate .ttf fonts using icomoon: Open the iconmoon application. Remove the current set(if there is one) and create a new empty set and give your preferred name(Remember to give same name everywhere). Drag and drop your SVG files on the tool. Select the files which you want to export. Select all if you want to export all the icons. After the selection, click generate font. This will download a zip file on your system. The zip file will contain a selection.json file fonts folder containing a .ttf file. We only need these two files to use fonts in react-native. Put the fontfile(.ttf) in resources/fonts folder and add the following script to the package.json: \"rnpm\": { \"assets\": [ \"resources/fonts\" ] } This script will copy the font files to both android and iOS folders. After this, whenever we want to update the fonts, we will do react-native link react-native-vector-icons and the fonts will be copied/updated automatically to both android and iOS projects. Put the JSON file (selection.json) in your app and create a file called CustomIcon.js and import the selection.json which you exported in the previous step. import {createIconSetFromIcoMoon} from 'react-native-vector-icons'; import icoMoonConfig from './selection.json'; export default createIconSetFromIcoMoon(icoMoonConfig); That's it, to use a font simply import the file as a react component and pass the icon name and size(optional) or even style. import CustomIcon from './components/CustomIcon.js' //To use the icon // To pass size // To pass custom tyle Changing file names of the fontfile The default name of the fontfile is icomoon.ttf. If you want to give a different name, go to Preferences after step 5 and change the name there before downloading. Also, make sure that if you change the fontfile name, give the same name to the set as well(by default its \"Untitled Set\") It is not recommended to change the filename of .ttf fontfile after the setup/native linking. The filename gets written in project.pbxproj and Info.plist and the file gets copied to android/app/src/main/assets/fonts/ once you run the link command. If you wish to change the filename, you would need to take care of changing the above 2 files as well, and removing the unused icon from android folder which might cause problems if not done properly._ How do I add/delete icons from the fontfile(.ttf) You can easily change/delete the contents of fontfile. The tool just needs selection.json file, which defines the font configuration. The steps for the same are as follows: Open IcoMoon App Upload the current selection.json file. Edit/Delete the icon using the tools on top. (Adding the Icon is same as step 3 mentioned above) After the editing is complete, generate a new fontfile by following the steps 5 and 6 mentioned above. Once you have the new fontfile and the new selection.json file, place them in their locations and do react-native link react-native-vector-icons. That's how you you change the icons. Pretty neat huh? This will let us convert any svg image to font which is scalable, platform independent and easy to style. What else can you ask for, right? The code till here can be found on the branch chapter/11 "},"13-internationalization/13.1-framework-intro.html":{"url":"13-internationalization/13.1-framework-intro.html","title":"Internationalization","keywords":"","body":"Internationalization For application developers, internationalizing an application means abstracting all of the strings and other locale specific things like date, currency etc. We will create a file called en.js and hi.js containing all the strings in a flat JSON format. Our Presentational components will import the string from one of these files depending on the current language. Both the language files will contain same keys at any point of time. Framework for Internationalization We will be using react-native-i18n. It integrates I18n.js with React Native and uses the user preferred locale as default. I18n.js is a very famous vanilla JS library which supports features like Date/Time localization, Number localization, Locale fallback, etc. You can find more info about i18n.js here; Note that the only feature this module gives us is getting the device locale as default app locale. If you do not need this feature, you may skip installing the native module and use i18n-js module instead. Setting up the framework Lets start by installing the NPM module. yarn add react-native-i18n After this is done, we would need to link it to our app using react-native link react-native-i18n Create language js files containing language strings in flat JSON format. We will follow the convention of _contentTypeInCameCase. Reason for this convention is it will be easier of the testers/devs to know if a translation is missing, considering, we will be having guess mode ON(explained later). Example: config/language/en.js export default { HOME_noteTitle: 'Note Title', HOME_pleaseTypeYourNote: 'Please type your note below', HOME_startTakingNotes: 'Start taking notes', HOME_save: 'Save', HOME_characters: 'chacters', ABOUT_us: 'About Us', ABOUT_theApp: 'About the app', ABOUT_theCreators: 'About the Creators', ABOUT_theAppDesc: 'About the app', ABOUT_theCreatorsDesc: 'About the Creators', }; Create a utility file which will export a translate function and a some other utility functions. Refer to the comments to know what each line/function does utils/language.utils.js import I18n from 'react-native-i18n'; // You can import i18n-js as well if you don't want the app to set default locale from the device locale. import en from '../config/language/en'; import hi from '../config/language/hi'; I18n.fallbacks = true; // If an english translation is not available in en.js, it will look inside hi.js I18n.missingBehaviour = 'guess'; // It will convert HOME_noteTitle to \"HOME note title\" if the value of HOME_noteTitle doesn't exist in any of the translation files. I18n.defaultLocale = 'en'; // If the current locale in device is not en or hi I18n.locale = 'en'; // If we do not want the framework to use the phone's locale by default I18n.translations = { hi, en }; export const setLocale = (locale) => { I18n.locale = locale; }; export const getCurrentLocale = () => I18n.locale; // It will be used to define intial language state in reducer. /* translateHeaderText: screenProps => coming from react-navigation(defined in app.container.js) langKey => will be passed from the routes file depending on the screen.(We will explain the usage later int the coming topics) */ export const translateHeaderText = (langKey) => ({screenProps}) => { const title = I18n.translate(langKey, screenProps.language); return {title}; }; export default I18n.translate.bind(I18n); Setup is done, now lets import the translations from the utility file instead of hardcoding it the components. Instead of {text.length} characters We will do {text.length} {translate('HOME_characters')} After following the above 5 steps, we will have Internationalization framework setup and all our strings coming from a single language config file. Lets change the defaultLocale of the app from en to hi in language.utils.js and see if our framework setup works. TADA! Our setup works like a charm and we can see everything in hindi The code till here can be found on the branch chapter/13/13.1 "},"13-internationalization/13.2-language-toggle.html":{"url":"13-internationalization/13.2-language-toggle.html","title":"Adding language toggle feature","keywords":"","body":"Adding language toggle feature Our framework setup for internationalization is done, but the important part is still left, which is implementing change language feature. Every internationalization enabled app will have this feature. Lets go ahead and build the same for our beloved NoteTaker app. Lets start by adding a toggle button in our Home component. The button should show the current language and should toggle the language onPress. For this, we would need: Current language from redux store. Ability to change the language on action dispatch. For now, we will create a button in Home.component.js which will accept currentLanguage and toggleLanguage function as a props. Home.component.js const {..., currentLanguage, toggleLanguage} = this.props; return ( ... {currentLanguage} ... ) Integration with redux store Create a userPreference reducer which will have a key called language. The initialState of language should come from language.utils. Our reducer would look something like this: reducers/userPreferences.reducer.js import {CHANGE_LANGUAGE} from '../actions/index.actions'; import {getCurrentLocale} from '../../utils/language.utils'; const initialState = {language: getCurrentLocale()}; const userPreferences = (state = initialState, action) => { switch (action.type) { case CHANGE_LANGUAGE: { return {...state, language: action.payload}; } default: return state; } }; export default userPreferences; We need to make sure that the language in redux store is always in sync with the language in i18n module. In other words, we need an action creator which changes the language in both i18n module and redux store. We will use redux-thunk middleware for this. You can use redux-saga to achieve this as well. To know more about thunks, visit here. redux/thunks/index.thunks.js import {changeLanguage} from '../actions/index.actions.js'; import {setLocale} from '../../utils/language.utils'; export const setCurrentLanguage = (lang) => (dispatch) => { setLocale(lang); dispatch(changeLanguage(lang)); }; export const toggleLanguage = () => (dispatch, getState) => { const currentLanguage = getState().userPreferences.language; if (currentLanguage === 'en') { dispatch(setCurrentLanguage('hi')); } else { dispatch(setCurrentLanguage('en')); } }; After defining the setCurrentLanguage and toggleLanguage, we can dispatch them onPress of our toggle button. Lets pass toggleLanguage and currentLanguage to the Home Component. Home.page.js import {toggleLanguage} from '../redux/thunks/index.thunks'; class HomePage extends Component { render () { const {..., toggleLanguage, currentLanguage} = this.props; return ( ); } } const mapStateToProps = (state) => ({ ... currentLanguage: state.userPreferences.language }); const mapDispatchToProps = (dispatch) => ({ ... toggleLanguage: () => dispatch(toggleLanguage()) }); That's all! You should now be able to see a toggle button on the home page showing the current language and toggling the language on press. Don't worry about the header text not being changed. We will fix it in the coming chapter. The code till here can be found on the branch chapter/13/13.2 "},"13-internationalization/13.3-integration-with-react-navigation.html":{"url":"13-internationalization/13.3-integration-with-react-navigation.html","title":"Integration with react-navigation","keywords":"","body":"Integration with react-navigation Our framework setup is done, toggle language feature is also done. Everything seems to be working, except one bug. The header text is not getting re-rendered on language change. Have a look at the screenshot below. The current language is hindi. Everything changes on the UI except the header. But why is this happening? We are using translate function in routes file right? Answer: Right, but how will the router know that it has to re-render? Luckily, react-navigation provides us this feature to pass screenProps. ScreenProps will be passed to each navigator instance's navigationConfig. We can pass screenProps as a prop to the Router component in our App.container. App.container.js However, change in screenProps will not cause re-rendering of Router. Have a look at the issue here to know why. To fix this, we would use a function instead of an object for our navigationConfig(have a look at Dynamic Configuration topic here). ScreenProps are passed to this function and we can use them to get the currentLanguage and then translation. Instead of navigationOptions: { title: translate('HOME_startTakingNotes') } We will do navigationOptions: ({screenProps}) => { const title = I18n.translate('HOME_startTakingNotes', screenProps.language); return {title}; }; Doing this will fix the dynamic change of the header text based on the currentLanguage. Lets create a utility for this so that don't have to rewrite this function. language.utils.js export const translateHeaderText = (langKey) => ({screenProps}) => { const title = I18n.translate(langKey, screenProps.language); return {title}; }; Lets use this utility in all our routes file. Example usage: routes/index.js navigationOptions: translateHeaderText('HOME_startTakingNotes') Our app now supports internationalization without any bugs 🕵🏻 The code till here can be found on the branch chapter/13/13.3 "},"16-custom-native-modules/16.0-intro.html":{"url":"16-custom-native-modules/16.0-intro.html","title":"Custom Native Modules","keywords":"","body":"Custom Native Modules Although react native has extensive amounts of native module libraries available thanks to the huge open source community around it, sometimes there are specific requirements that arise during the project which needs native platform api access which react native doesn't provide. As an example : Lets say you are working for a client and they have a custom SDK for authentication. And the client has SDK for iOS, Android and Web. Although you are building native app for Android/iOS on top of a Web technology (React), the irony is that this task suddenly becomes difficult. Solution: The beauty of React Native is that it is designed to be a bridge between Native code and web technologies. Thus all you need to do is simply integrate the native iOS and android sdks onto the respective native projects and expose the methods and variables via the React Native Native Modules methods. We will discuss how to create custom wrapper modules that can be used to invoke native code from javascript in the next chapters. On a side note, if the requirement was that we need to integrate a native module that doesn't need to interact with the javascript layer then we can safely integrate the native modules in the respective native projects for iOS and android and not create a react native bridge itself. One such use case can be crash reporters which need to send a crash report if an app crashes. So here you only integrate the crash reporter on the native code base of iOS and android and you do not expose any method to the javascript side. The initialisation also happens when the native app starts. Thus, technically if a functionality is supported by the native platform, it can be supported in React Native. "},"16-custom-native-modules/16.1-android-native-module.html":{"url":"16-custom-native-modules/16.1-android-native-module.html","title":"Android Native Modules","keywords":"","body":"Android custom native module Lets say we want to build a native module that gets you the device name. Before we continue, remember if you want to write code for android, please open the android project on Android studio. This is because android studio is built for android development and it will help you resolve all the trivial errors that otherwise would take up your time. Lets begin. Open the ./android/ project in android studio. Create a Java class file android/app/src/main/java/com/notetaker/device/DeviceModule.java This is our main custom native module file. The custom native module class should extend ReactContextBaseJavaModule. When done so, we will have to to implement getName() method. The getName method basically contains the name by which the module will be exported to the js. In order to expose a method from native java module to javascript just write a method and add @ReactMethod annotation on top of it. These methods can be accessed from NativeModules of react-native package. See the below example: android/app/src/main/java/com/notetaker/device/DeviceModule.java package com.notetaker.device; import com.facebook.react.bridge.Callback; import com.facebook.react.bridge.ReactApplicationContext; import com.facebook.react.bridge.ReactContextBaseJavaModule; import com.facebook.react.bridge.ReactMethod; public class DeviceModule extends ReactContextBaseJavaModule { //constructor public DeviceModule(ReactApplicationContext reactContext) { super(reactContext); } //Mandatory function getName that specifies the module name @Override public String getName() { return \"Device\"; } //Custom function that we are going to export to JS @ReactMethod public void getDeviceName(Callback cb) { try{ cb.invoke(null, android.os.Build.MODEL); }catch (Exception e){ cb.invoke(e.toString(), null); } } } Here we are exporting a method getDeviceName() from native to javascript. This method can be accessed in js as import {NativeModules} from 'react-native'; NativeModules.Device.getDeviceName((err ,name) => { console.log(err, name); }); NativeModules has a key named 'Device'. This is basically the same name we exported using the method getName. And getDeviceName is exported because of `@ReactMethod. We passed a callback to get the value from the NativeModule. But creating a module file is not enough. Before a native module can be used we need to register the module. To do this we create another Java class android/app/src/main/java/com/notetaker/device/DevicePackage.java package com.notetaker.device; import com.facebook.react.ReactPackage; import com.facebook.react.bridge.JavaScriptModule; import com.facebook.react.bridge.NativeModule; import com.facebook.react.bridge.ReactApplicationContext; import com.facebook.react.uimanager.ViewManager; import java.util.ArrayList; import java.util.Collections; import java.util.List; public class DevicePackage implements ReactPackage { @Override public List createViewManagers(ReactApplicationContext reactContext) { return Collections.emptyList(); } @Override public List createNativeModules( ReactApplicationContext reactContext) { List modules = new ArrayList<>(); //We import the module file here modules.add(new DeviceModule(reactContext)); return modules; } // Backward compatibility public List> createJSModules() { return new ArrayList<>(); } } This file just imports our Module and instantiates it. The last step in the registration process is to now instantiate our DevicePackage class. To do this modify the file android/app/src/main/java/com/notetaker/MainApplication.java ... ... import com.notetaker.device.DevicePackage; ... ... ... @Override protected List getPackages() { return Arrays.asList( new MainReactPackage(), ... ... new DevicePackage() //Add your package here ); } }; ... ... ... Thats it, lets give it a shot!. In a java script file like app/index.js just add import {NativeModules} from 'react-native'; ... ... NativeModules.Device.getDeviceName((err, name) => console.log(err, name)); ... ... Running this on an android emulator returns. Woot ! That was simple ! The code till here can be found on the branch chapter/16/16.1 Note that the if you try to build iOS, the build will fail as we have not implemented the Device module in iOS yet. "},"16-custom-native-modules/16.2-ios-native-module.html":{"url":"16-custom-native-modules/16.2-ios-native-module.html","title":"iOS Native Modules","keywords":"","body":"iOS custom native module Lets build the same native module that we built for android last chapter. The purpose remains the same, the native module should get you the device name set on the iPhone. Before we continue, just a reminder if you want to write code for iOS, please open the iOS project on Xcode. This is because Xcode is built for ios development and it will help you resolve all the trivial errors that otherwise would take up your time. Lets begin. Open the ./ios/ project folder. Open .xcodeproj file or .xcworkspace file in Xcode. Create a header file Device.h by File -> New -> File -> Header File and then name the file Device.h and choose the targets. Create a new folder Device if you like to organise files in a folder like me. Let modify our Device.h file. ios/Device/Device.h #import @interface Device : NSObject @end This is our main custom native modules header file. Now lets create the corresponding implementation file Device.m in the same location. ios/Device/Device.m #import \"Device.h\" @implementation Device RCT_EXPORT_MODULE(); @end Like the android's getName method, Here we have RCT_EXPORT_MODULE() macro. If no name is explicitly provided it will take the name of the module. Here the name of the module is 'Device'. In order to expose a method from native module to javascript just write a method inside the RCT_EXPORT_METHOD macro. These methods can be accessed from NativeModules of react-native package. See the below example: ios/Device/Device.m #import \"Device.h\" #import @implementation Device //export the name of the native module as 'Device' since no explicit name is mentioned RCT_EXPORT_MODULE(); //exports a method getDeviceName to javascript RCT_EXPORT_METHOD(getDeviceName:(RCTResponseSenderBlock)callback){ @try{ NSString *deviceName = [[UIDevice currentDevice] name]; callback(@[[NSNull null], deviceName]); } @catch(NSException *exception){ callback(@[exception.reason, [NSNull null]]); } } @end Here we are exporting a method getDeviceName() from native to javascript. This method can be accessed in js as import {NativeModules} from 'react-native'; NativeModules.Device.getDeviceName((err ,name) => { console.log(err, name); }); NativeModules has a key named 'Device'. This is basically the same name exported by RCT_EXPORT_METHOD. We passed a callback to get the value from the NativeModule. Thats it, lets give it a shot!. In a javascript file like app/index.js just add import {NativeModules} from 'react-native'; ... ... NativeModules.Device.getDeviceName((err, name) => console.log(err, name)); ... ... Running this on an android emulator returns. Woot ! That was simple ! The code till here can be found on the branch chapter/16/16.2 "}}